[{"title":"Http协议","date":"2019-08-30T10:20:15.000Z","path":"2019/08/30/Http协议/","text":"what is HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议； HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）； 连接时需要3次握手、断开时需要4次挥手； 工作原理 HTTP是无连接： 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间； HTTP是媒体独立的： 只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型； HTTP是无状态： 无状态是指协议对于事务处理没有记忆能力； 缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大； 在服务器不需要先前信息时它的应答就较快； 消息结构 Http消息包括请求消息和响应消息两部分； HTTP请求报文由请求行（request line）、请求头（header）、空行和请求数据4个部分组成； 请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成； HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法； HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法； 请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔； 请求数据POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length； HTTP响应也由三个部分组成，分别是：状态行、响应头、空行、响应正文； 在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息，状态行通过提供一个状态码来说明所请求的资源情况。 状态代码由三位数字组成，第一个数字定义了响应的类别； 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。 常见的状态码： 200 OK：客户端请求成功。 400 Bad Request：客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。 403 Forbidden：服务器收到请求，但是拒绝提供服务。 404 Not Found：请求资源不存在，举个例子：输入了错误的URL。 500 Internal Server Error：服务器发生不可预期的错误。 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。通用头部 Request URL:请求的URL地址； Request Method: 请求方法，get/post/put/delete……； Status Code：状态码，200 为请求成功； Remote Address：路由地址；请求头部 Accept：告诉WEB服务器自己接受什么介质类型，/ 表示任何类型，type/* 表示该类型下的所有子类型； Accept-Charset：浏览器申明自己接收的字符集； Accept-Encoding：浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法 （gzip，deflate）； Accept-Language：浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等； Authorization：当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，该头部来回应自己的身份验证信息给WEB服务器； Connection：表示是否需要持久连接（close、keep-alive）； Referer：发送请求页面URL。浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL； User-Agent: 浏览器表明自己的身份（是哪种浏览器）； Host： 发送请求页面所在域； Cache-Control：浏览器应遵循的缓存机制： no-cache（不要缓存的实体，要求现在从WEB服务器去取）； max-age：（只接受 Age 值小于 max-age 值，并且没有过期的对象）； max-stale：（可以接受过去的对象，但是过期时间必须小于 max-stale 值）； min-fresh：（接受其新鲜生命期大于其当前 Age 跟 min-fresh 值之和的缓存对象）； Pramga：主要使用 Pramga: no-cache，相当于 Cache-Control： no-cache； Range：浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分； Form：一种请求头标，给定控制用户代理的人工用户的电子邮件地址； Cookie：这是最重要的请求头信息之一； 响应头部 Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。 Accept-Ranges：WEB服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。 Cache-Control：服务器应遵循的缓存机制。 public(可以用 Cached 内容回应任何用户) private（只能用缓存内容回应先前请求该内容的那个用户） no-cache（可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端） max-age：（本响应包含的对象的过期时间） ALL: no-store（不允许缓存） Connection： 是否需要持久连接 close（连接已经关闭）。 keepalive（连接保持着，在等待本次连接的后续请求）。 Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：Keep-Alive：300 Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。 例如：Content-Encoding：gzip Content-Language：WEB 服务器告诉浏览器自己响应的对象的语言。 Content-Length：WEB 服务器告诉浏览器自己响应的对象的长度。例如：Content-Length: 26012 Content-Range：WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。例如：Content-Range: bytes 21010-47021/47022 Content-Type：WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml Expired：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。 Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。 Location：WEB 服务器告诉浏览器，试图访问的对象已经被移到别的位置了，到该头部指定的位置去取。 Proxy-Authenticate： 代理服务器响应浏览器，要求其提供代理身份验证信息。 Server: WEB 服务器表明自己是什么软件及版本等信息。 Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。 附录HTTP协议.pdf","tags":[{"name":"http","slug":"http","permalink":"https://jmzc4j.github.io/tags/http/"}]},{"title":"Idea常用配置","date":"2019-08-30T07:29:27.000Z","path":"2019/08/30/Idea常用配置/","text":"IntelliJ IDEA常用配置 View-&gt;勾选Tool Bar与Tool Buttons ；设置显示常见的视图,调出工具条和按钮组； File-&gt;Settings：打开设置视口； Appearance &amp; Behavior-&gt;Theme ：设置主题； Keymap-&gt;选择eclispe模式 ：设置快捷为 Eclipse；或者 File Import Settings ：导入已有的快捷键设置； Editor-&gt;General-&gt;勾选Change font size(Zoom)… ：设置Ctrl + 鼠标滚轮修改字体大小； Editor-&gt;General-&gt;勾选Show quick document on mouse… ：设置鼠标悬浮提示； Editor-&gt;General-&gt;Auto Imporp-&gt;勾选Add unambigous import…和Optimize imports… ：设置自动导包； Editor-&gt;General-&gt;Appearance-&gt;勾选Show line number和Show method seperators ：设置显示行号和方法间的分隔符; Editor-&gt;General-&gt;Code Completion-&gt;Case sensitive completion-&gt;none ：忽略大小写提示； Editor-&gt;General-&gt;Editor Tabs-&gt;取消勾选Show tabs in single row ：取消单行显示tabs； Editor-&gt;Font ：设置字体； Editor-&gt;File and Code Templates-&gt;Includes-&gt;File Header : 修改类头的文档注释信息; Editor-&gt;File Encodings-encoding相关全部改为utf-8，并勾选Transparent native-to-ascii conversion ： 设置项目文件编码； Editor-&gt;Live Templates ；自定义模板； Build,Execution,Deployment-&gt;勾选build project auto..和Compile independent.. ：设置自动编译； Build,Execution,Deployment-&gt;Build Tools-&gt;Maven : 配置maven； Build,Execution,Deployment-&gt;Application Server-&gt;’+’号，添加配置tomcat； Version Control-&gt;Git ： 配置git；常用插件 .ignore : git忽略文件； CamelCase ：驼峰式命名和下划线命名交替变化； CheckStyle-IDEA ： 代码样式检查； Statistic : 代码统计； Eclipse Code Formatter ： Eclispe风格格式化； Maven Helper ： Maven辅助； GsonFormat : 把 JSON 字符串直接实例化成类； FindBugs-IDEA ： 代码 Bug 检查； Lombok ；Lombok支持； PlanUML intergration ：UML插件； 如何删除模块 选中模块-&gt;右键Open Module Settings-&gt;点击’-‘号-&gt;将module从project移除-&gt;delete; 附件idea配置详解 快捷键定制包","tags":[{"name":"idea","slug":"idea","permalink":"https://jmzc4j.github.io/tags/idea/"}]},{"title":"Hexo插入音乐或视频","date":"2019-08-29T10:50:33.000Z","path":"2019/08/29/Hexo插入音乐或视频/","text":"使用hexo-tag-aplayer插件 官网地址：hexo-tag-aplayer; 安装命令：npm install --save hexo-tag-aplayer; 语法格式： 1&#123;% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125; 语法参数说明： 12345678title : 曲目标题;author: 曲目作者url: 音乐文件 URL 地址;picture_url: (可选) 音乐对应的图片地址;narrow: （可选）播放器袖珍风格;autoplay: (可选) 自动播放，移动端浏览器暂时不支持此功能;width:xxx: (可选) 播放器宽度 (默认: 100%);lrc:xxx: （可选）歌词文件 URL 地址; 当开启Hexo的文章资源文件夹功能时可以将图片、音乐文件、歌词文件放入与文章对应的资源文件夹中，然后直接引用; hexo根路径配置文件中开启配置，post_asset_folder: true; 正确的引用图片方式是使用下列的标签插件而不是 markdown ： 123456&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125;例如：要引入一个图片:&#123;% asset_img example.jpg This is an example image %&#125; 开启资源目录后，只需在歌词和路径属性中填写文件名即可，例如： 1&#123;% aplayer &quot;Caffeine&quot; &quot;Jeff Williams&quot; &quot;caffeine.mp3&quot; &quot;picture.jpg&quot; &quot;lrc:caffeine.txt&quot; %&#125; 歌词标签 除了使用标签 lrc 选项来设定歌词，你也可以直接使用 aplayerlrc 标签来直接插入歌词文本在博客中; 123&#123;% aplayerlrc &quot;title&quot; &quot;author&quot; &quot;url&quot; &quot;autoplay&quot; %&#125;[00:00.00]lrc here&#123;% endaplayerlrc %&#125; 播放列表123456789101112131415161718192021222324252627&#123;% aplayerlist %&#125;&#123; &quot;narrow&quot;: false, // （可选）播放器袖珍风格 &quot;autoplay&quot;: true, // （可选) 自动播放，移动端浏览器暂时不支持此功能 &quot;mode&quot;: &quot;random&quot;, // （可选）曲目循环类型，有 &apos;random&apos;, &apos;single&apos;, &apos;circulation&apos;, &apos;order&apos; (列表)， 默认：&apos;circulation&apos; &quot;showlrc&quot;: 3, // （可选）歌词显示配置项，可选项有：1,2,3 &quot;mutex&quot;: true, // （可选）该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 &quot;theme&quot;: &quot;#e6d0b2&quot;, // （可选）播放器风格色彩设置，默认：#b7daff &quot;preload&quot;: &quot;metadata&quot;, // （可选）音乐文件预载入模式，可选项： &apos;none&apos; &apos;metadata&apos; &apos;auto&apos;, 默认: &apos;auto&apos; &quot;listmaxheight&quot;: &quot;513px&quot;, // (可选) 该播放列表的最大长度 &quot;music&quot;: [ &#123; &quot;title&quot;: &quot;CoCo&quot;, &quot;author&quot;: &quot;Jeff Williams&quot;, &quot;url&quot;: &quot;caffeine.mp3&quot;, &quot;pic&quot;: &quot;caffeine.jpeg&quot;, &quot;lrc&quot;: &quot;caffeine.txt&quot; &#125;, &#123; &quot;title&quot;: &quot;アイロニ&quot;, &quot;author&quot;: &quot;鹿乃&quot;, &quot;url&quot;: &quot;irony.mp3&quot;, &quot;pic&quot;: &quot;irony.jpg&quot; &#125; ]&#125;&#123;% endaplayerlist %&#125; MeingJS 支持 (3.0 新功能) MetingJS 是基于Meting API的APlayer衍生播放器，引入 MetingJS 后，播放器将支持对于 QQ音乐、网易云音乐、虾米、酷狗、百度等平台的音乐播放; 如果想在本插件中使用 MetingJS，请在 Hexo 配置文件 _config.yml 中设置： 12aplayer: meting: true 接着就可以通过 在文章中使用 MetingJS 播放器了(开启后似乎不能使用第一种方式): 12345&lt;!-- 简单示例 (id, server, type) --&gt;&#123;% meting &quot;60198&quot; &quot;netease&quot; &quot;playlist&quot; %&#125;&lt;!-- 进阶示例 --&gt;&#123;% meting &quot;60198&quot; &quot;netease&quot; &quot;playlist&quot; &quot;autoplay&quot; &quot;mutex:false&quot; &quot;listmaxheight:340px&quot; &quot;preload:none&quot; &quot;theme:#ad7a86&quot;%&#125; 有关 的选项列表如下: 12345678910111213141516id 必须值 歌曲 id / 播放列表 id / 相册 id / 搜索关键字server 必须值 音乐平台: netease, tencent, kugou, xiami, baidutype 必须值 song, playlist, album, search, artistfixed false 开启固定模式mini false 开启迷你模式loop all 列表循环模式：all, one,noneorder list 列表播放模式： list, randomvolume 0.7 播放器音量lrctype 0 歌词格式类型listfolded false 指定音乐播放列表是否折叠storagename metingjs LocalStorage 中存储播放器设定的键名autoplay true 自动播放，移动端浏览器暂时不支持此功能mutex true 该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停listmaxheight 340px 播放列表的最大长度preload auto 音乐文件预载入模式，可选项： none, metadata, autotheme #ad7a86 播放器风格色彩设置 hexo-tag-dplayer插件(好像不太好用) 官网地址：hexo-tag-dplayer; 安装命令：npm install hexo-tag-dplayer --save; 语法格式： 1&#123;% dplayer key=value ... %&#125; 语法参数说明： 123456789101112131415161718192021222324252627282930常用选项：url、loop、volume、autoplay、hotkey、logo、mutex、highlight、preload、theme;autoplay false 视频自动播放;theme &apos;#b7daff&apos; 主题色;loop false 视频循环播放;hotkey true 开启热键，支持快进、快退、音量控制、播放暂停;preload &apos;auto&apos; 视频预加载，可选值: &apos;none&apos;, &apos;metadata&apos;, &apos;auto&apos;;volume 0.7 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效;logo - 在左上角展示一个 logo，你可以通过 CSS 调整它的大小和位置;highlight [] 自定义进度条提示点;mutex true 互斥，阻止多个播放器同时播放，当前播放器播放时暂停其他播放器;url - 视频链接;pic - 视频封面;thumbnails - 视频缩略图;type &apos;webvtt&apos; 字幕类型，可选值: &apos;webvtt&apos;, &apos;ass&apos;，目前只支持 webvtt;fontSize &apos;20px&apos; 字幕字号;bottom &apos;40px&apos; 字幕距离播放器底部的距离，取值形如: &apos;10px&apos; &apos;10%&apos;;color &apos;#fff&apos; 字幕颜色;id required 弹幕池id，必须唯一;api required 见[弹幕接口](http://dplayer.js.org/zh/guide.html#%E5%BC%B9%E5%B9%95%E6%8E%A5%E5%8F%A3);addition - 额外外挂弹幕,见[bilibili 弹幕](http://dplayer.js.org/zh/guide.html#bilibili-%E5%BC%B9%E5%B9%95);token - 弹幕后端验证 token;maximum - 弹幕最大数量;unlimited false 海量弹幕模式;user &apos;DIYgod&apos; 弹幕用户名;其他参数请参考[dplayer](https://github.com/MoePlayer/DPlayer); 举例1&#123;% dplayer &quot;url=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.mp4&quot; &quot;addition=https://dplayer.daoapp.io/bilibili?aid=4157142&quot; &quot;api=https://api.prprpr.me/dplayer/&quot; &quot;pic=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.jpg&quot; &quot;id=9E2E3368B56CDBB4&quot; &quot;loop=yes&quot; &quot;theme=#FADFA3&quot; &quot;autoplay=false&quot; &quot;token=tokendemo&quot; %&#125; (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"http://p0e6ktyto.bkt.clouddn.com/MSN%20%E6%9C%80%E5%90%8E%E7%9A%84%E4%B8%89%E9%87%8D%E5%A5%8F_%20%E7%BB%9D%E5%94%B12017_%E9%AB%98%E6%B8%85.mp4\",\"pic\":\"https://i.imgur.com/n3YAGhq.jpg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()","tags":[{"name":"hexo","slug":"hexo","permalink":"https://jmzc4j.github.io/tags/hexo/"}]},{"title":"Dos命令","date":"2019-08-29T09:57:50.000Z","path":"2019/08/29/Dos命令/","text":"dos 下查看端口 netstat -ano | findstr 4000：查看4000端口详细信息; tasklist | findstr 6068：在任务列表中找到对应PID为6068的进程; taskkill /F /PID 6068：强制杀死6068进程;","tags":[{"name":"dos","slug":"dos","permalink":"https://jmzc4j.github.io/tags/dos/"}]},{"title":"Linux之Shell初识","date":"2019-08-29T06:32:27.000Z","path":"2019/08/29/Linux之Shell初识/","text":"Shell概述 Shell是一个命令解释器，为用户提供一个向内核发送请求的界面；同时它还是解释执行的脚本语言。 Shell分为两大类，B家族Shell和C家族Shell，可以在/etc/shells中查看系统支持哪些Shell。 Shell语言编写和执行 脚本文件通常以”.sh”后缀标记，脚本的开头要标注Shell类型”#!/bin/bash”。 执行方式：赋予执行权限，也可以使用“bash xxx.sh”或者“sh xxx.sh”的方式执行。 注释 单行注释“#”和多行注释“:!&lt;&lt;…!” 多命令的执行顺序 “;”：使用分号连接多个命令，这些命令间没有关系，不管前面的命令是否正确执行后面的都会执行。 “&amp;&amp;”：使用逻辑与连接多个命令，只有前面的命令正确执行后面才执行。 “||”：使用逻辑或连接多个命令，只有前面的命令不正确后面才执行。 Shell中变量 set：可以查看所有变量包括环境变量；env：可以查看所有环境变量。unset 变量名：可以销毁一个变量；$变量名：可以使用一个变量。$(命令)：可以将命令的结果当做变量的值。或者使用反引号也可以。 自定义变量 格式：变量=值 （注意：等号两边没有空格）。 使用readonly关键字声明静态变量，此时该变量不能被销毁。 export 自定义变量：可以将自定义变量提升为系统变量。 系统变量（环境变量） 系统变量名一般大写。 source或者. 可以重新加载配置文件。 位置参数变量 用来接受命令中的相应位置的参数。 $n：$0表示这条命令本身，$1-$9、$(10)、$(11)…表示第n个参数。 $*：表示所有的参数，将所有参数作为一个整个。 $@：也表示所有参数，将所有参数分别对待，常用在循环中。 $#：表示所有参数的个数。 预定义变量 $$：表示当前进程的PID。 $!：表示后台进程中的最后一个进程的PID。 $?：表示一个命令的执行状态，0表示正确执行。 键盘输入 read [选项] [变量]常用选项 -t：该命令的等待时间，单位是秒。 -p：给出提示信息。 -s：隐藏输入数据。 read -s -t 30 -p “请输入你的年龄：” age 提取命令 cut -d 分隔符 -f 指定列 ：按指定分隔符提取指定列，通常和grep配合使用。 cat /etc/passwd | grep /bin/bash | grep -v root | cut -d “:” -f 1 awk &#39;条件1{动作1} 条件2{动作2}...&#39; 文件 还是不太懂！！！ sed命令（流编辑器） 比vi更强大，用的不多，可以对管道符的结果进行编辑。 sed [选项] &#39;动作&#39; 文件 还是不懂！！！ 排序命令和统计命令 sort与wc 运算符 $((运算式))或者$[运算式]：可以使用这样的方式取得运算式的值。 判断符 [ 判断式 ]；注意中括号与判断式中有空格。 文件比较 A -oq B和A -nq B：判断文件A的修改时间是不是比B旧或者新。 -e、-d、-f：判断文件是否存在，存在并且是目录、存在并且是文件。 A -ef B：判断A文件与B文件的inode是否一致。 数值比较 -eq、-gt、-lt、ge、le、ne。 字符串比较 str1==str2或者str1 = str2：判断字符串相等，注意等号的空格。 -n或者-z：判断是否是空串，前者非空返回真，后者空返回真。 str1!=str2：不等判断。 流程控制 if结构 123if [ 条件 ];then 程序片段fi 或者 1234if [ 条件 ] then 程序片段fi 或者 123456789if [ 条件 ] then 程序片段 elif [ 条件 ] then 程序片段 else 程序片段fi case结构 1234567891011case $变量名 in&quot;值1&quot;) 等于值1的代码;;&quot;值2&quot;) 等于值2的代码;;*) 不匹配的代码;;esac for结构 1234for 变量 in 值1 值2 值3 ...do 程序片段done 或者 1234for((初始值;条件;增量))do 程序片段done while结结构 1234while [ 条件式 ]do 程序片段done 函数 系统函数basename [filepath] [suffix] ：取得filepath路径中的文件名并排除suffix后缀 basename /home/aaa/bbb.txt .txt 结果是bbb basename /home/aaa/bbb.text 结果是bbb.txt dirname [filepath] :取得filepath路径的目录部分 dirname /home/aaa/bbb.txt 结果是/home/aaa 自定义函数 1234[function] functionname()&#123; 函数体 [return xxx] &#125; 综合案例 要求 1. 每天凌晨2：10备份数据库mydb到/data/backup/db 2. 备份开始和结束要有提示信息 3. 备份后的文件以备份时间作为文件名，并打包*.tar.gz 4. 备份的同时检查有10天前的备份，如果有删除 代码 12345678910111213141516171819202122232425262728293031323334353637#!/bin/bash #定义备份目录BACKUP=/data/backup/db#获取当前系统时间NOWDATE=$(date +%Y_%m_%d_%H%M%S)#定义数据库的主机名DBHOST=192.168.238.133#定义数据库的端口DBPORT=3306#定义数据库的用户名DBUSER=root#定义数据库的密码DBPWD=root#定义要备份的数据库DBNAME=mydbecho &quot;=====开始备份=====&quot;#确保备份路径存在,路径不存在或者不是目录就创建一个目录if [ ! -d &quot;$DACKUP/$NOWDATE&quot; ]then mkdir -p &quot;$DACKUP/$NOWDATE&quot; echo &quot;备份文件绝对路径为 $DACKUP/$NOWDATE.tar.gz&quot;fi#进行mysql数据库的冷备份,比正常备份多了一个压缩（即 | gzip部分且不能直接使用tar）mysqldump -h$DBHOST -P$DBPORT -u$DBUSER -p$DBPWD $DBNAME | gzip &gt; $DACKUP/$NOWDATE/$NOWDATE.sql.gz#切换到备份目录cd $DACKUP#进行打包操作tar -zcvf $NOWDATE.tar.gz $NOWDATE#删除临时的目录rm -rf ./$NOWDATE#找到备份目录下最后修改时间大于10天并且以.tar.gz结尾的文件进行删除find $DACKUP -mtime +10 -a -name &quot;*.tar.gz&quot; -exec rm -rf &#123;&#125; \\;echo &quot;=====备份完毕=====&quot;","tags":[{"name":"linux","slug":"linux","permalink":"https://jmzc4j.github.io/tags/linux/"}]},{"title":"Linux命令","date":"2019-08-29T06:32:09.000Z","path":"2019/08/29/Linux命令/","text":"命令格式 命令名 [选项] [参数] 中括号“[]”代表可选。 选项可以使以减号“-”开头的缩写，还可以是以双减号“–”开头的英文全称，可以多个选项联合使用。 参数可以使0个、1个、多个。 常用命令帮助 man 命令名：用来查看指定命令名的帮助，该命令也可以查看配置文件的帮助。 命令名 --help：用来查看命令选项的帮助。 whereis 命令名：可以查找命令的所在目录及该命令帮助的所在目录。 清屏 ctrl+l或者clear：清屏。ctrl+u和ctrl+y：剪切和粘贴命令 vi/vim编辑器 vi 文件：创建或打开一个文件。 命令行模式（一般模式）：使用vi刚刚打开文件的模式。常用命令 gg、G、nG、0、$：移动光标都第一行、最后一行、第n行、当前行行首、当前行行尾。 x、D、dd、ndd、dG：删除当前光标处、剪切光标到行尾、当前行、当前行开始的n行、当前行到最后一行的内容。 yy、nyy、p、P、r、R、：复制当前行、当前行开始的n行、粘贴到光标下一行、上一行、替换当前光标的字符、光标出开始替换直到ESC结束。 u：撤销上一次操作。 ZZ：退出vi。 插入模式（编辑模式）：从命令行模式输入aioAIO中任意一个进入的模式，使用ESC退出。 底行模式（冒号模式）：从命令行模式输入:进入模式。常用命令 set nu(set nonu)：设置显示或取消行号。 linenumber：移动光标到指定的linenumber行。 /keyword（？keyword）：按关键词从光标处向下查找或向上查找。 set ic(set noic)：设置忽略或区分大小写。 n1,n2d：删除n1行到n2行之间的内容。 %s/old/new/g：使用新串全文替换旧串。 n1,n2s/old/new/g：使用新串在指定行间进行替换旧串。 w、w 目录、wq、q!、wq!：保存、另存、保存退出、不保存退出、强制保存退出。 小技巧 :map 快捷键 操作：自定义快捷键，如 :map ^p I# 。 :ab 缩写 原意：为全称定义一个缩写名字，然后使用缩写名字+空格即可完成全名的输入。 ~/.vimrc：可以在此文件中定义底行模式的命令使其永久生效。 定义别名 alias 别名 命令：为命令定义一个临时别名。 ~/.bashrc：编辑该文件可以永久定义别名。 目录与文件命令 ls [选项] [目录或者文件]：查看目录或文件的内容或属性。常用选项-alh -a：显示隐藏文件。 -l：长列表显示。 -h：人性化显示。 -i：显示i节点信息。 可以使用通配符(*、?)或者正则匹配([]、[-]、[^]…)。 tree [目录]：列出指定目录的树状结构并统计目录和文件数量。 pwd；查看当前工作目录的绝对路径。 cd [目录]：切换目录。 cd ~或者cd：切换到家目录。 cd ..：切换到上一级目录。 mkdir [选项] 目录：创建目录。常用选项-pm -p：创建多级目录。 -m: 使用数字表示法指定目录的权限。 cp [选项] 目录或文件 目标目录：复制目录或文件到已存在的目标目录或。常用选项-ri -r：递归复制目录内容。 -i：如果遇到同名文件会提示是否覆盖。 mv [选项] 目录或文件 目标目录：剪切目录或文件到已存在的目标目录或者执行改名操作。常用选项-if -f：如果遇到同名文件不会提示是否覆盖。 -i：–interactive。如果遇到同名文件会提示是否覆盖. rm [选项] 目录或者文件：删除一个目录或者文件。常用选项-rf -r：递归删除目录及目录下的所有内容。 -f：–force，不在有提示信息强制删除。 touch 文件：创建一个新的空白文件或者是更新一下已存在文件的修改时间。 ln -s 目录或文件 软链接文件：为一个文件或目录创建一个软链接，类似于快捷方式，软连接文件的权限是777. 查看文件内容命令 cat [选项] 文件：使用与浏览内容较少的文件。常用选项-bn -b：–number-nonblank，行号只标记有效行(即非空白行)。 -n：–number，带行号显示，不挑剔。 more 文件：可以分页查看文件内容。辅助命令f、b、enter、q b：上一页。 f：下一页，也可以使用空格键。 enter：下一行。 q：退出。 less [选项] 文件：同样是分页查看文件内容，但是可以带行号，还能搜索。常用选项MN -M：使用后类似于more的百分比。 -N：带行号显示。 辅助命令同more，可以使用“/keyword”进行搜索。 head [-n 数字] 文件；显示到指定行号的文件内容，默认显示前10行。 tail [选项] 文件；从尾部开始显示文件内容，默认显示后10行。常用选项-nf -n 数字：显示指定的后几行。 -f：–follow，跟踪显示文件的变化，常用来查看日志。 输出重定向与管道命令、历史命令 &gt; 文件:将一个到终端的输出重定向到文件中，即向文件中覆盖内容。&gt;&gt; 文件：同样是重定向到终端的输出，追加到文件的末尾。&amp;&gt;&gt; 文件：将错误和正确结果都追加到文件末尾。 命令A | 命令B：将命令A的输出结果通过管道符作为命令B的输入参数，可以通过管道符“|”执行多个命令。 ehco 字符串：输入指定内容到终端，相当于编程语言中的打印。 history [数量]：可以查看历史命令列表或者查看指定数量的历史命令列表，之后可以使用“!历史命令编号”来执行指定命令。~/.bash_history：历史命令保存在该文件中，默认保存上限可以在profile中修改。 查找命令 find 目录 搜索条件：在指定目录范围内根据指定条件查找指定的内容。常用选项 -name：按名称查找，可以使用通配符或者正则。 -size：按大小查找，如-size +200K（大于200K的）、size -10M（小于10M的）。 -user：按用户名查找。 -type：按文件类型查找。如-type “d”、-type “-“。 -mtime：按文件的最后修改时间查找，该时间单位是天，如-mtime +10（最后修改时间距现在10天以上的）。 可以使用“-a”或者“-o”进行条件的拼接，前者表示and，后者表示or。 可以使用“-exec”选项来对查找的结果进行处理，如find /etc -name init -exec ls -l {} \\;,着重部分是固定格式。 locate [-i] 要查找的内容：快速查找或者忽略大小写查找。说明 可能系统为安装该命令，需要执行yum -y install mlocate。 每次使用前最好执行updatedb命令更新locate检索库。 grep [选项] 字串 文件或者是命令的输出结果：从指定的文件或者一个命令输出结果中过滤查找需要的内容。常用选项-ivn -i：忽略大小写查找。 -v：排除指定字串查找。 -n:查找结果带行号显示。 字串可以使用通配符或者正则，如*、？、^、$。 时间日期命令 date [-s] [+时间格式：按指定格式设置或显示系统时间。格式说明：%Y表示年份、%m表示月份、%d表示天、%H表示0-23的小时、%M表示分钟、%S表示秒。 cal [年份]：查看当前时间的日历或者查看指定年份的日历。 ntpq -p：与NTP服务器进行时间同步，CentOS7请使用chronyc sources命令。 /etc/sysconfig/clock：配置时区，CentOS7使用tiemdatectl set-timezone Asia/Shanghai命令。 /etc/sysconfig/i18n：配置语言环境，CentOS7使用localectl set-locale LANG=zh_CN.UTF-8命令。 文件压缩和解压缩命令 gzip 文件和gunzip 文件：以gzip格式压缩和解压文件，只能压缩文件且不会保留原文件。 zip [-r] 文件或目录 压缩后的文件 要压缩的文件：以zip格式压缩目录或文件。unzip [-d 目录] 要解压的文件：以zip格式解压文件到当前目录或指定目录。 tar [-zcvf] 要压缩打包的目录或文件：以gzip压缩并使用tar进行打包指定文件。tar [-zxvf] 要解压的文件 [-C 目标目录]：解压.tar.bz2文件到当前目录或指定的已存在的目录。 tar [-jcvf] 要压缩打包的目录或文件：以bzip2压缩并打包指定文件。tar [-jxvf] 要解压的文件 [-C 目标目录]：解压.tar.bz2文件到当前目录或指定目录。 网络与服务命令 ipconfig或者ip addr：查看网卡信息，后者是CentOS7上或者Ubuntu18上使用。 ping IP地址：测试与目标IP地址的连通性。 netstat -rn：可以查看路由列表。netstat -tulnp或者netstat -anp：查看进程的网络连接状态。选项说明：r表示路由、n表示IP地址和端口号、t表示tcp连接、u表示udp连接、l表示监听状态、p表示PID和应用、a表示全部。 如何配置静态IP地址 CentOS中配置方式：修改 /etc/sysconfig/network-scripts/ifcfg-eth0(或者ens33)配置文件，修改内容类似下面。 1234567891011# 修改部分BOOTPROTO=&quot;static&quot; # 设置使用静态IP协议ONBOOT=&quot;yes&quot; # 设置开机启动网络服务# 添加部分DNS1=&quot;114.114.114.114&quot; #设置DNS1DNS2=&quot;8.8.8.8&quot;GATEWAY=&quot;192.168.124.2&quot; # 设置网关IPADDR=&quot;192.168.124.124&quot; # 设置IP地址NETMASK=&quot;255.255.255.0&quot; # 设置子网掩码# 重启网络服务CentOS6.x：network，CentOS7.x:NetworkManager Ubuntu18中配置方式：修改/etc/netplan/01-network-manager-all.yaml配置文件，修改内容类似下面。 123456789101112network: version: 2 renderer: NetworkManager ethernets: ens33: dhcp4: no #关闭动态主机配置协议 addresses: [192.168.124.125/24] #设置IP地址，24表示24位的子网掩码(即255.255.255.0) gateway4: 192.168.124.2 #设置网关 nameservers: addresses: [8.8.8.8, 114.114.114.114] #设置DNS# Ubuntu18中重启方式：sudo netplan apply - ls /etc/init.d：可以系统中通过rpm安装的独立服务列表。 服务管理 /etc/init.d/服务名 stop|start|restart|status:对某个服务停止、启动、重启，查看状态。 service 服务名 stop|start|restart|status。 systemctl stop|start|restart|reload|status 服务名。（CentOS7的管理方式） service --status-all；查看所有的服务状态。CentIS7使用systemctl list-units。 自启动管理 chkconfig --list [| grep xxx] : 查看所有服务或者具体服务在各个运行级别的状态。 chkconfig [--level runlevel] 服务名 on/off：设置服务在所有级别或指定级别的开启自启与关闭。 systemctl enable/disable xxx.service：同样可以设置开机自启与关闭，使用于CentOS7. systemctl list-unit-files：查看所有的自启动状态。 防火墙管理 /etc/init.d/iptables：配置该文件可放开端口。 firewall-cmd --zone=public [--remove-port|--query-port|--add-port]=80/tcp --permanent：CentOS7的方式。 firewall-cmd --reload：重启防火墙。 firewall-cmd --zone=public --list-ports：查看防火墙列表。 系统运行级别管理命令 系统运行级别分为六大类（括号内的表示在CentOS7中的标识）。 0：表示关机。 （poweroff.target）。 1：表示单用户模式 （emergency.target）。 2：表示多用户无网络模式 （rescure.target）。 3：表示多用户有网络模式 （multi-user.target）。 4：表示保留级别，未被使用。（无） 5：表示图形界面模式 （graphical.target）。 6：表示重启 （reboot.target）。 CentOS7中的这些名称可以通过ll /lib/systemd/system/runlevel*查到。 runlevel：能够查看系统之前和当前的运行级别。vi /etc/inittab；通过该配置文件也可以查到系统运行级别。systemctl get-default；在CentOS7中可以通过该命令查看当前运行级别。 init 级别ID；可以切换运行级别。vi /etc/inittab：在该文件中配置默认运行级别。systemctl set-default xxx.target：CentOS7的配置默认运行级别的方式。 进程管理命令 ps aux与ps au：查看当前系统进程的详细信息，一般使用后者即可，表示只显示终端上的进程。ps -ef：同样能查看当前系统进程信息，还能查到父进程的PID。pstree [选项]：查看系统进程树。常用选项： -p：查看指定PID的进程。 -u：查看指定用户名的进程。 top：动态实时的显示系统进程并排序，还可以监控系统的健康状态。 kill -1 PID：重启指定PID的进程。kill [-9] PID：结束或强制结束指定PID的进程。killall 进程名：结束与指定进程相关的所有进程。pkill : 可以用来踢出指定终端的用户 用户和组管理命令 相关配置文件分别是/etc/passwd、/etc/shadow、/etc/group、/etc/gshadow。 /etc/passwd：分别表示用户名、标识口令、UID、初始GID、备注、家目录、登录Shell。 /etc/shadow：分别表示用户名、加密口令、最新修改日期、下次可修改间隔、有效期限、提前警告天数、过期可用天数、截止日期、保留。 /etc/group：分别表示组名称、标识口令、组ID、组用户列表。 /etc/gshadow：分别表示组名称、加密口令、组管理者列表、组用户列表。 useradd [选项] 用户名：添加新用户。常用选项 -g：添加到初始组，一个用户只能有一个初始组（也称之为主组）。 -G：添加到附加组，一个用户可以有多个附加组（也就是组配置文件中用户列表中所对应的组）。 -d：指定家目录的位置。 -u：指定UID，普通用户的UID都是500之后的数字，超级用户的UID是0。 -s：设置使用的登录shell类型 -r：–system ，创建一个系统账号，这样的账号不会再/home下创建家目录。 -m：–creat-home，设置要在/home下创建家目录。 -M：–no-create-home ，设置不创用户的家目录。 passwd 用户名：为指定用户设置口令。 userdel [-r] 用户名：删除指定用户或者同时删除家目录。usermod [选项] 用户名：可以修改用户信息，选项同新增用户选项。 id [用户名]；查看用户的UID和GID信息。who或者w；查看所有登录用户的详细信息。whoami：查看当前用户名称。 su [-] 用户名：切换到指定目录。可以不用切换root用户，而使用sudo来管理系统。 groupadd 组名、groupdel 组名、groupmod 组名。 文件权限管理命令 使用ls -l可以查看文件或目录的详细信息。 这些信息分别表示文件类型和ugo权限、硬链接数(可访问方式的数量)、所有者、所属组、文件大小、最后修改时间、文件名（即basename）。 文件的rwx：表示可查看、修改文件内容、可执行该文件。 目录的rwx：表示可查看、在目录中创建目录文件或修改目录内容、可进入该目录。 chmod [-R] {[ugoa]+/-/=[rwx]} 目录或文件：修改(添加、减少、设置)所有者或所属组或其他用户或所有用户对指定目录或文件的读写执行权限。chmod [-R] [rwx=421] 目录或文件：使用数字表示法设置目录或文件的权限，如chmod 755 temp.sh。 chown [-R] 用户名 目录或文件：变更目录或文件的所有者为指定用户。chgrp [-R] 组名 目录或文件： 变变目录或文件的所属组为指定组。chown [-R] 用户名:组名 目录或文件：同时变更目录或文件的所有者和所属组。 磁盘管理命令 lsblk [-f]：查看分区和挂载信息,-f,–fs。 使用fdisk -l也能查看。df [-lha]：查看整个磁盘的使用情况,-l,–local。du [-ach --max-depth=0开始的数字] [目录或文件]：查看指定目录或目录所有内容的磁盘使用情况并统计，还能灵活的指定目深度。du -sh 目录 mount：查看系统中挂载哪些分区。mount /dev/sr0 /mnt/cdrom：挂载光驱设备到/mnt/cdrom。mount -t vfat /dev/sdb1 /mnt/usb：挂载一个fat32格式的U盘，U盘的设备名称也是以“sd”开头的。Linux默认不支持NTFS格式的U盘，需要安装ntfs-3g软件包才能正常使用。 如何为系统添加一块新硬盘(以第二块硬盘sdb为例)。 分区分为MBR(主引导记录)和GPT(GUID分区表)两大类，前者主分区最多4个，支持硬盘容量有限；后者主分区无上限，支持容量达18EB，可能受操作系统限制。 对于SCSI(小型机系统接口)或SATA(串行高级技术附件)硬盘在Linux文件系统中都是保存在/dev下的以’sd’开头的目录中。 准备好要添加的硬盘。 fdisk /dev/sdb：为sdb硬盘进行分区。 mkfs /dev/sdb：格式化sdb硬盘，根据提示进行，格式化进行将文件系统写入硬盘。 mkdir /mnt/newdisk：创建挂载点。 mount /dev/sdb /mnt/newdisk：执行临时挂载操作，当然也可通过unount进行卸载。 vi /etc/fstab：修改配置文件以便使挂载永久生效。 mount -a：根据/etc/fstab的配置重新进行挂载。 定时调度命令 crontab -e：打开定时调度配置文件进行编辑 从左到右五个时间符号分别表示：分钟、小时、日、月、星期。 “*”表示任意时间，“*/n”表示每隔多长时间，“-”表示一段时间，“，”表示几个时间点。 crontab -l：查看有定时任务列表。crontab -r：删除所有定时任务。 软件包管理命令 rpm管理 rpm -qa 包名：查询指定rpm包的安装情况。 rpm -ql 包名:查询指定rpm包的安装位置。 rpm -qR 包名:查询指定rpm包的依赖信息。 rpm -qf 目录：查询指定目录下安装的rpm包列表。 rpm -ivh 包全名；安装指定rpm包，显示安装详情和安装进度。 rpm -e [--nodeps] 包名：卸载或者强制卸载指定rpm包。 rpm -Uvh 包名：升级安装包。 yum管理 yum [-y] list：查询安装列表。 yum [-y] install 包名：安装。 yum [-y] remove 包名 ：卸载。 yum [-y] update 包名：升级。 yum [-y] grouplist：查询软件组列表。 yum [-y] groupinstall 软件组名、yum [-y] removegroup软件组名。 可以更新yum源：位置在/etc/yum.repos.d/目录下。 Ubuntu apt管理 sudo apt-get update：修改软件源之后可以使用该命令重新加载软件源。 源更新方式可以去tuna上找：https://mirrors.tuna.tsinghua.edu.cn/ 。 sudo apt-get install 包名：安装包。 sudo apt-get remove 包名：卸载包。 sudo apt-get upgrade 包名：更新已安装的包。 sudo apt-cache show 包名：获取包的相关信息。 sudo apt-get source 包名：下载该包的源代码。 关机和重启命令 shutdown -r time：指定时间重启，默认是1分钟。shutdown -r now等价于reboot。shutdown -h time ：指定时间关机。shutdown -h now等价于halt。shutdown -c；取消上一个shutdown命令。sync：同步命令，同步数据到磁盘。 其他命令 hostname：查看主机名。uname -a：查看内核版本详情。/proc/cpuinfo；查看cpu信息。free -m：以MB单位查看内存信息。/etc/issue：查看查看发行版本。 SSH windows上使用公私密钥对登录 创建一组密钥对并保存好私钥。 将公钥内容导入到指定用户的家目录的.ssh目录下的authorized_keys文件中。 禁用密码登录 vi /etc/ssh/sshd_config 设置密码认证为no。 service sshd restart 禁用root登录：vi /etc/ssh/sshd_config -&gt; PermitRootLogin no 改掉ssh端口：vi /etc/ssh/sshd_config -&gt; Port=xxx Linux上使用ssh ssh -p username@IP ssh-sshgen -t rsa -b 2048 ssh-copy-id username@IP SCP scp -P user@服务器IP:绝对路径 客户机文件 SFTP sftp -oPort user@IP 使用help查看使用","tags":[{"name":"linux","slug":"linux","permalink":"https://jmzc4j.github.io/tags/linux/"}]},{"title":"Linux概述","date":"2019-08-29T06:32:00.000Z","path":"2019/08/29/Linux概述/","text":"一、科普知识操作系统(operating system) 操作系统就是一个可以直接操作硬件的特殊的软件，是具有如下作用的软件。 管理和操作硬件设备。 将对硬件的操作封装成一个又一个的系统调用供其他应用程序使用。 针对应用领域的不同可以将操作系统分成桌面、服务器、嵌入式和移动设备四大类。 桌面操作系统（desktop OS）：Windows、macOS、Linux。 服务器操作系统（server OS）：Linux、Windows Server。 嵌入式操作系统（embedded OS）：Linux。 移动设备操作系统（mobile OS）：IOS、Android。 针对用户不同又分为单用户和多用户操作系统。 单用户操作系统：一台计算机同一时间只能由一个用户使用，该用户独享全部的硬件和软件资源。 多用户操作系统：一台计算机同一时间只能由多个用户使用，多个用户共享全部的硬件和软件资源。 网卡(netcard)与IP地址(internet protocol address) 网卡是一个专门负责网络通讯的硬件设置，就是那个连接网线的有线网卡和连接wifi的无线网。 IP地址就是设置在网卡上的一个逻辑地址信息，它可以唯一标识一个网卡，同时它也是计算机在互联网上的一个唯一标识。 IP地址由网络号段和主机号段组成，以“点-数法”表示，分成ABCDE五类；子网掩码的作用就是来区分网络号段和主机号段的；网关实质上也是一个具有路由功能的设备的IP地址。 域名(domain name)与端口号(port number) 域名说白了就是IP的别名，具有更好的易记性，通过域名也能准确定位到一台计算机；而端口号指的是TCP/IP协议的端口号，是用来区分网络上不同的应用程序的，通过域名和端口号可以准确的定位到一台计算机上的服务应用程序。 二、细说LinuxLinux的历史 1965年贝尔实验室(Bell Labs)、麻省理工(MIT)以及通用电气(GE)合作的MULTICS计划，欲要开发一套多用户的(multi-user)、多任务的(multi-processor)、多层次的(multi-level)操作系统,最终因各种原因失败。 1969年贝尔实验室的Ken Thompson为了能更好的玩“星际旅行”的游戏，历时一个月使用汇编写出了UNIX操作系统的原型；1970年设计出了B语言，使用该语言完成了第一个UNIX(UNICS的谐音)操作系统。 1971年同样酷爱“星际旅行”的Dennis Ritchie加入了Thompson的开发项目进行B语言的改造；到1972年的时候成功在B语言的基础上设计出了C语言；于1973年二人用C语言重写了UNIX操作系统。 1991年芬兰大学生Linus Torvalds在Minix的基础上开发了Linux的原型，之后利用GNU的bash开发环境和gcc编译工具编写了Linux内核；后来和众多爱好者共同完成了现如今强大的Linux操作系统。 Linux的概述 Linux就是指Linus’s UNIX，它是一个开放源代码的UNIX，本意是Linux内核的意思，后来被人们称之为Linux操作系统。具有免费、稳定、安全的特点。 Linux分为内核版本和发行版本。 内核版本：是Linux的核心，是运行程序和管理硬件设备的核心程序，官网地址为https://www.kernel.org。 发行版本：是封装了Linux内核的功能更加强大的Linux操作系统，又分成RedHat系列(如CentOS)和Debian系列(如Ubuntu)。 CentOS官网：https://www.centos.org;Ubuntu官网：https://www.ubuntu.com;踩点和扫描网址：https://www.netcraft.com。 Linux的文件系统和目录结构 Linux的文件系统是一个层级的树状目录结构，没有盘符的概念，只有一个根目录“/”,所有文件都在它下面。 Linux的主要目录介绍： /：根目录，一切目录的源头。一般只保存目录。 /boot:启动目录，保存系统启动需要的文件，如内核文件/boot/vmlinuz、引导器/boot/grub。(重点) /bin、/usr/bin；可执行二进制文件目录，保存的是如ls、tar这样的普通命令，可供所有用户使用。(重点) /sbin、/usr/sbin：系统可执行二进制文件目录，保存跟系统管理相关命令，但该目录的命令只能是超级管理员使用。 /etc：系统配置文件的默认存放目录，一般只存放配置文件，如/etc/inittab、/etc/init.d、/etc/sysconfig、/etc/fstab、/etc/issue。(重点) /home：系统默认的普通用户的家目录，如新建一个名为jmzc的用户，那么家目录就是/home/jmzc。(重点) /root：超级用户root的家目录。(重点) /lib、/usr/lib、/usr/local/lib：系统的函数库目录，程序执行需要额外调用的函数都保存在这里。 /usr：全称是unix sofrware resource,系统软件资源目录，类似于windows中的Program Files目录。(重点) /mnt、/media：挂载目录，前者是用户临时挂着其他文件系统的目录，后者是系统自动识别的设备的默认挂载目录。(重点) /lost+fount：系统异常产生错误时，会将一些遗失的片段放到此目录中。 /opt；安装第三方软件的目录；通常我们也会使用/usr/local目录作为第三方软件的安装目录。(重点) /proc:虚拟文件系统，该目录的文件只保存在内存中，如/proc/version、/proc/cpuinfo。 /sys、/srv：和/proc目录一样都是跟系统内核相关的目录，非高手不要动它。 /tmp：临时文件目录。 /dev：硬件设备存放目录。(重点) /var：动态数据的存在目录，如，日志，邮件等。(重点) /selinux：全称security enhanced linux，安全增强子系统，类似于360防护。 /dev/null、/dev/zero：2个特殊的目录，一个回收站，一个用于磁盘复制（dd命令）。三、使用Linux你需要知道的几个常识 linux中的内容都是以文件的形式保存的，包括硬件，即“在Linux中，一切皆文件”。 linux中的存储设置一般需要挂载之后才能使用。 Linux作为远程服务器时一般不允许关机，只能重启而且重启前最好同步数据并关闭服务。 Linux中的文件不是以后缀名来区分，而是用文件的权限来区分的。 linux作为服务器要定期的备份重要数据和日志。 用户密码需要具有规范性、时效性、易记性和复杂性。 通常不要直接使用系统预设用户“root”来登录，而要使用普通用户登录。","tags":[{"name":"linux","slug":"linux","permalink":"https://jmzc4j.github.io/tags/linux/"}]},{"title":"JVM初识","date":"2019-08-29T05:01:43.000Z","path":"2019/08/29/JVM初识/","text":"JVM内存模型 JVM是运行在操作系统之上的，它与硬件没有直接的交互； 堆空间和方法区被线程共享;程序计数器、虚拟机栈和本地方法栈被线程私有； 常见的JVM实现有SUN hotspot、BEA jrockit、IBM j9； 类装载器 负责加载class文件，class文件在文件开头有特定的文件标示，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定; 装载过程： 加载：查找并加载字节码文件到内存 准确说是将字节码文件的内容加载到运行时数据区的方法区中，并在内存中创建一个Class对象。 连接 验证：验证字节码文件的正确性 准备：为静态变量分配空间并进行默认初始化 解析：将符号引用转变为直接引用 初始化：为静态变量进行真实初始化 只有在首次主 装载器分类 虚拟机自带的加载器: 启动类加载器（Bootstrap）C++ 扩展类加载器（Extension）Java 应用程序类加载器（App）Java 也叫系统类加载器，加载当前应用的classpath的所有类 用户自定义加载器 Java.lang.ClassLoader的子类，用户可以定制类的加载方式; 执行引擎 Execution Engine执行引擎负责解释命令，提交操作系统执行（java、javac）; Native Interface本地接口 Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问; 本地方法栈 登记native方法，在Execution Engine执行时加载本地方法库; PC寄存器 每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记; 虚拟机栈 主管Java程序的运行，在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。基本类型的变量、实例方法、引用类型变量都是在函数的栈内存中分配。 java.lang.StackOverflowError：当线程请求深度大于虚拟机允许的深度时发生异常; 方法区 方法区是线程共享的，通常用来保存装载的类的元结构信息。比如：运行时常量池+静态变量+常量+字段+方法字节码+在类/实例/接口初始化用到的特殊方法等。 通常和永久区关联在一起(Java7之前)，但具体的跟JVM的实现和版本有关。 堆空间 一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行。 堆内存逻辑上分为三部分：新生+养老+永久（JDK8以前）; 新生区 新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命； 新生区又分为两部分：伊甸区（Eden）和幸存者区（Survivor），所有的类都是在伊甸区被new出来的。幸存区有两个： 0区（Survivor 0 space）和1区（Survivor 1 space）; 当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(MinorGC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存0区.若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生MajorGC（FullGC），进行养老区的内存清理。若养老区执行了FullGC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。 如果出现java.lang.OutOfMemoryError: Java heap space异常，说明Java虚拟机的堆内存不够。原因有二： Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。(初始大小一般是物理内存1/64,最大1/4) 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。 新生代调整参数：-Xmn；永久代调整参数：-XX:PermSize和-XX:MaxPermSize。 -XX:+PrintGCDetails :输出GC处理日志。 使用如下API获取JVM堆内存参数 12long maxMemory = Runtime.getRuntime().maxMemory() ;//返回 Java 虚拟机试图使用的最大内存量。long totalMemory = Runtime.getRuntime().totalMemory() ;//返回 Java 虚拟机中的内存总量。 JVM采用分代回收机制 新生代使用复制算法copying，会浪费50%空间； 年老代使用标记清除和标记整理算法mark-sweep（会产生不连续的内存碎片）和mark-compack；","tags":[{"name":"jvm","slug":"jvm","permalink":"https://jmzc4j.github.io/tags/jvm/"}]},{"title":"Html初识","date":"2019-08-29T04:57:50.000Z","path":"2019/08/29/Html初识/","text":"一 软件的架构 C/S架构：(client-server)客户端服务器架构： 用户需要安装客户端来使用软件； 每次服务端更新后需要更新客户端； 针对不同的操作系统，需要开发不同的客户端程序，跨平台性差； 使用自有协议，相对来说安全性较好； B/S架构：(browser-server)浏览器服务器架构: 不需要安装客户端，只要有一个浏览器即可； 软件更新不需要更新客户端； 由于只需开发服务端，跨平台性较好； 使用公共的http协议或者https协议，相对C/S架构来说可能安全性稍差； 网页组成：根据w3c的标准，一个网页主要由结构、表现和行为组成，即html、css和js。 二 HTML html：hypertext markup language,超文本标记语言： 不是一门编程语言，而是一门告诉浏览器如何组织页面的标记语言，决定了网页的结构； 元素是html的基本单位，通常情况下，一个元素有开始标签、结束标签和内容构成； HTML标签不区分大小写，从可读性和一致性方面通常使用小写字母； 元素按照性质可分成块级元素和内联元素两大类别； 没有内容的元素称之为空元素； 可以在开始标签中为元素添加属性，属性通常是一组由等号连接的名值对，值用引号包裹； 当属性没有值或者其值为属性名本身，这样的属性称之为布尔属性； 完整的html页面的组成: 文档类型声明，h5声明，最短的有效的文档声明； html根元素，包裹了一个完整html页面； head元素，包裹了所有想包含在html页面中但不想在页面中显示的内容，如标题、描述、关键字、字符集等； body元素，包裹了所有想在网页中显示的内容，如文本、图片、音频、视频等； 三 HTML元素 元数据：meta 标题和段落：h、p 超链接和图片：a、img、figure、picture 列表：ul、ol、dl 实体：&amp;amp; &amp;nbsp; &amp;lt; &amp;gt; &amp;copy; &amp;quote; 表格：table、tr、td、th、colgroup、col、thead、tfoot、tbody、caption 表单：form、input（text、password、file、hidden、checkbox、radio、email、number、tel、search）、textarea、select、fieldset 语气：em、strong、ins、del、small 引用：blockquote、q、cite 缩略语和上下标：abbr、sup、sub 代码：code、pre 换行和水平分割线：br、hr 布局：div、span 语义布局：header、nav、main、section、article、aside、footer 音频和视频：audio、video 四 CSS css：cascading style sheets，层叠样式表： 指定文档如何呈现给用户的语言，用来定义文档的样式和布局，决定了网页的表现； css的基本单位就是一个个css规则，一个规则由选择器和css声明块组成（与值配对的属性称之为css声明）； css工作原理： 浏览器加载html并解析，然后加载css并解析，在然后将解析后的html和css在dom树上进行渲染，最后呈现给用户； 添加样式表的方式：外部样式表、内部样式表和内联样式表；五 css选择器 基本选择器：元素选择器、类选择器、ID选择器、通用选择器、分组选择器； 关系选择器：子元素选择器（&gt;）、后代选择器、交集选择器、兄弟选择器(+、~) 属性选择器：E[att]、E[att=”val”]、E[att^=”val”]、E[att$=”val”]、E[att*=”val”]、E[att|=”val”]、E[att~=”val”] 伪类选择器：E:link、E:visited、E:hover、E:active、E:focus、E:not()、E:first-child、、E:nth-child(n)、E:nth-of-type(n)、E:empty、E:checked、E:disabled、E:enabled 伪元素选择器：E:after/E::after、E:before/E::before 六css中单位 长度单位：px、em、百分比 颜色单位：rgb、代表颜色的单词、十六进制七 规则优先级 在外部添加样式的情况下，id选择器&gt;类选择器、伪类选择器、属性选择器&gt;元素选择器、伪元素选择器","tags":[{"name":"html","slug":"html","permalink":"https://jmzc4j.github.io/tags/html/"}]},{"title":"Java基础","date":"2019-08-29T04:57:13.000Z","path":"2019/08/29/Java基础/","text":"数据类型 Java作为强类型语言，将数据类型分成基本类型和引用类型。 基本数据类型（primitive）：byte、short、int、long、float、double、char、boolean(4类8种)； 引用数据类型（reference）：array、class、interface（除了基本类型的都是引用类型）； 作为面向对象的语言，每种基本数据类型都有其对应的包装类型Number(6种)、Character、Boolean；流程控制 和其他语言一样分成顺序、选择和循环结构。 选择：if-else、switch-case； 循环：do-while、while、for、foreach；面向对象 面向过程和面向对象 面向过程：强调功能本身，关注的是如何分步的去完成功能，将方法或函数看做是一个基本单位；此时的程序编写者就是一个执行者； 面向对象：强调具备该功能的对象，关注的是如何指挥对象去完成功能，将类或者对象看做是一个基本单位；此时的程序编写者就是一个指挥者； 面向对象编程：就是找寻对象、创建对象、使用对象、维护对象间关系的过程； 类和对象 类：将现实世界中的事物在概念世界的抽象；反映到Java语言中就是一个类或者接口。 对象：就是那个事物本身，是个实实在在的个体；反映到Java语言中就是类的实例或者接口的具体实现。 Java中类的组成：类中有属性（Field）、方法（Method）、构造器（Constructor）基础元素，还可以有内部类元素。 方法 方法可以说就是一个最小的封装单位，通常由方法名、参数列表、方法体、返回值类型和访问权限修饰符组成； 方法重载：一个类中出现方法名相同、参数列表不同的现象； 方法重写：子父类中出现一模一样的方法的现象（即方法名、参数列表和返回值都一样）； 重写的方法不能比父类中的方法的出现更多的异常；也不能比父类中的方法的访问权限更严格；静态方法不能重写； 面向对象的三大特性 封装（encapsulation）：隐藏对象的属性和实现细节，并提供对外的访问方式；具体就是使用private私有属性并提供setter和getter方法。 不可见性：细节不可见； 安全性：避免了非法数据的产生； 复用性：不论内部如何变，类始终不变； 继承（inheritance）：将多个类中的公共部分提取到一个单独的类中，让这个类和多个类产生了“is a”的关系，将这种关系称之为继承；使用extends表示类或者接口之间的继承关系。 父类也称之为基类、超类（superclass）；子类也称之为派生类（subclass）； 一个类有且只能有一个父类；一个父类可以有多个子类（单继承）； 如果B继承A，C继承B，那么C也间接继承了A（多层继承），java.lang.Object类是继承体系中的根父类； 可以继承父类中出构造外所有的结构，但因为封装的不可见性，则不能直接访问私有成员； 子类实例化必先进行父类的初始化，就是说子类构造器中的必然有一个构造器的第一行是super()； 继承减少了代码的冗余，提高了代码复用性； 多态（polymorphism）：同一对象在运行时的不同表现形态；表现形式是父类引用指向子类对象。 前提：存在继承或实现关系；有方法的重写或方法的实现； 对属性来说是不存在多态现象的，就是说成员变量看左边； 对方法来说：编译时看父类的引用，运行时看具体的子类实例（动态绑定）； 父类不能使用子类中的成员，若想使用则需要向下转型(instanceof)； 当使用子类重写的方法而不是父类方法的现象称为虚拟方法调用，此时父类中的那个方法称之为虚拟方法（virtual method）； 抽象类与接口 当不要类创建对象时，我们可以使用abstract修饰类，这样的类就是一个抽象类；当不确定方法的具体实现时，可以使用abstract修饰，这样的方法称之为抽象方法；有抽象方法的类必须是抽象类，但抽象类不一定有抽象方法（模板设计模式）； 接口是类并列的一个结构，使用interface定义；JDK1.8之前，接口中只能有全局常亮和抽象方法；JDK1.8开始可以有静态方法和默认方法且默认方法只能通过接口调用；当默认方法和继承的父类方法一模一样时考虑类优先原则； 抽象类中通常定义基本功能，接口中定义扩展功能；接口反映的是“like a”的关系，是一种规则，一种可能性； this、super、static、final this：当前对象的引用（准确说是this所在的方法的所在类的对象）； super：父类对象的引用，和this一样都能用来区分同名成员； static：静态，用此修饰的成员变量称之为类变量，同样的用此修饰的成员方法称之为静态方法（类方法）； final：提升变量为常量（只能赋值1次）；修饰类则该类不能被继承；修改方法则该方法不能被重写； 异常 异常就是在程序运行过程中出现语法和逻辑错误之外的其他不正常情况的现象；有抛出和捕捉两种处理方式； 在异常的继承体系中，Throwable是Exception和Error的顶级父类，在Exception下有一个特殊的RuntimeException子类； 适当的处理异常能提高程序的健壮性和用户体验； try-catch-finally、throws、throw try-catch-finally：捕获并处理异常；try块中是可能出现问题的代码；chatch块中是对问题的解决方式的代码；finally块中是在虚拟机不退出的情况下都会执行的代码； throws：抛出一个或多个异常类型，提示方法调用者该方法可能会出现问题； throw：手动抛出一个异常对象，如该对象不是RuntimeException类型的子类，则需要显式throws声明； 自定义异常 当我们明确的知道如何解决问题时，通常自定义异常类继承Exception，然后throws该异常; 当不知道如何解决时，通常自定义类继承RuntimeException，然后好手动抛出一个改异常对象； 常用类与方法 java.lang.Object clone()、finalize()、hashCode()、equals()、toString()、wait()、notify()、notifyAll() java.lang.Runtime（一个典型的单例设计模式） getRuntime()、gc()、maxMemory()、totalMemory java.lang.System currentTimeMillis()、nanoTime()、arraycopy()、exit(0)、gc()、getProperties() java.lang.String concat()、join()、split()、subString() replace()、replaceFirst()、replaceAll()、compareTo()、equals()、equalsIgnoreCase()、matches() length()、charAt()、contains()、indexOf()、lastIndexOf()、startsWith()、endsWith() valueOf()、toCharArray()、getBytes()、format()、toUpperCase()、toLowerCase() trim()、isEmpty()、intern() new String(byte[])、new String(char[])、new String(StringBuilder) java.lang.StringBuffer与java.lang.StringBuilder append()、insert()、delete()、deleteCharAt()、setCharAt()、replace()、length()、charAt()、indexOf()、lastIndexOf()、toString()、subString() 默认容量16，扩容2*16+2 java.lang.Math Math.PI、Math.E abs()、ceil()、floor()、round()、max()、min()、random() java.util.Arrays asList()、sort()、binarySearch()、copyOf()、equals()、toString()、fill() java.util.Date与java.sql.Date getTime()、setTime()、after()、before()、new Date()、new Date(long) new Date(long)、valueOf() java.util.Calendar getInstance()、get()set()、add()、before()、after()、常量 java.text.SimpleDateformat new SimpleDateFormat(String)、format()、parse() java.time.LocalDateTime now()、of()、getXxx()、plusXxx()、minusXxx()、withXxx() java.time.Instant now()、plus()、minus() java.time.format.DateTimeFormatter DateTimeFormatter.ISO_LOCAL_DATE_TIME ofPattern(String)、format()、parse() java.lang.Integer valueOf()、compare()、compareTo()、parseInt()、xxxValue()、toString() java.math.BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) java.security,].MessageDigest(md5,sha-256) getInstance(String algorithm)、digest(byte[]) java.util.Base64 getDecode()、getEncode() decode()、encode() 线程 程序、进程和线程 程序：为实现某一功能，使用编程语言编写的一段静态代码或者是一组指令的集合； 进程：运行起来的程序，是资源分配的基本单位； 线程：程序中的一条执行路径，是程序执行的基本单位； 如果一个程序在同一时间可以并行的执行多个线程，那个称该程序为多线程程序； 创建线程的方式 extends Thread：覆盖run() implements Runbale：覆盖run() implements Callable-&gt;FutureTask：覆盖call() Executors-&gt;ThreadPoolExecutor-&gt;submit()/execute()/shutdown() 线程中常用方法 currentThread()、getName()、setName()、setPriority()、setDaemon() start()、sleep()、join()、yield()、interrupt() 线程状态 新建（new） 就绪（start、yield、notify） 运行（cpu分配了执行权） 阻塞（sleep、join、等待同步锁、wait） 死亡（run结束、出现异常、interrupt） 出现多线程问题的原因 多线程环境、有共享数据且有多条语句操作共享数据 线程同步 syncronized同步代码块：锁对象任意，多个线程共用同一把锁； syncnizzed同步方法：成员方法锁为this、类方法锁为clazz； reentrantLock锁：lock(),unlock() lock.newCondition()-&gt; await(),signal() 线程通信 wait、notify await、signal 注解和枚举 注解可以理解为源代码的补充代码，与反射技术配合使用 @interface：定义注解 元注解：（描述注解的注解）target：定义使用注解的元素类型，使用ElementType枚举类retention：定义注解的生命周期，使用RetentionPolicy枚举类inherited：document：repeatable： 枚举类就是定义有限个公共的全局对象常量的类。 enum定义枚举类，最直接父类是Enum；当一个枚举类中只有一个常亮时该枚举类就是一个单例的； 集合 Collection接口为单列集合的根接口，其子接口有List与Set。 List接口存储有序，元素可重复；实现类有ArrayList、LinkedList、Vector、Stack。 ArrayList和Vector底层数据结构是数组，数组默认长度是10，扩容方式前者1.5倍后者2倍；查询快，插入和删除慢； LinkedList：底层数据结果是双向列表，查询慢，插入和删除快； Set接口存储无序，元素不可重复；实现类有HashSet、LinkedHashSet、TreeSet。 HashSet：底层使用HashMap，即数组+链表+红黑树(1.8)的结构,默认容量16，加载因子0.75，临时容量12；当链表长度超过8，容量超过64则转换为红黑树存储。大概原理取得元素hashCode，通过散列算法计算元素位置；当该位置无元素直接添加，如果有元素那么要判断hashcode和equals的结果，hashcode和equals完全一样则不能添加； LinkedHashSet：底层在HashSet的基础上又多了一个双向链表来记录存储数据的顺序，所有取出和存储顺序是一致的； TreeSet：底层是红黑树，通过compareTo()或者compare()方法来确定元素位置。 Collection接口方法 add、addAll、clear、size、isEmpty、hashcode remove、removeALl、contains、containsAll、retainALl、equals toArray，iterator ArrayList特有方法 add(int,E)、get(int)、set(int,E)、remove(int)、subList(int,int) Map是双列集合的根接口，其实现类有HashMap、LinkedHashMap、TreeMap、Hashtable、Propeties 以键值对的方式存储元素，先将键值对存储到entry中然后将entry存到Map中； 存储无序，元素不可重复，因为key是Set、value是Collection； Map的方法 put、get、values、keySet、entrySet、size、isEmpty、remove、containsKey、containsValue、clear 泛型 泛型是参数化类型，就是类型的标记；实例化或者调用方法时需要明确具体类型； 可以用在类、接口、方法上；泛型方法可以是静态的；泛型方法的泛型类型不需要和类或接口中的泛型一致； 通配符：？，？extends G，？super G；不能做写操作，但可以做读操作； 文件和IO流 将文件系统抽象成File类，通过该类可以进行文件或目录的创建、删除、属性查看、目录内容查看等操作。 java.io.File中的常用方法 File.separator isFile()、isDirectory()、exists()、canRead()、canWrite()、isHidden() createNewFile()、mkdirs()、delete()、getParent() 、getName()、getAbsolutePath() list()、listFiles()、lastModified()、length() io流分类 按数据单位分为字节流和字符流 按流的流向分为输入流和输出流 按流的角色分为节点流（直接作用于文件的流）和处理流（对文件流或其他流的处理） 网络编程反射正则表达式Java8函数式编程","tags":[{"name":"java","slug":"java","permalink":"https://jmzc4j.github.io/tags/java/"}]},{"title":"Eclipse常用配置","date":"2019-08-28T16:48:08.000Z","path":"2019/08/29/Eclipse常用配置/","text":"Eclispe常用配置 Window-&gt;Preferences-&gt;General-&gt;勾选”show heap status”; Window-&gt;Preferences-&gt;General-&gt;Appearance-&gt;取消勾选”show most recently used tabs”; Window-&gt;Preferences-&gt;General-&gt;Appearance-&gt;Colors and Fonts-&gt;Basic-&gt;Text Font-&gt;Edit-&gt;调整字体大小; Window-&gt;Preferences-&gt;General-&gt;Content Types-&gt;Java Properties File-&gt;Default Encoding-&gt;修改为UTF-8-&gt;Update; Window-&gt;Preferences-&gt;General-&gt;Editors-&gt;Text Editors-&gt;Background color-&gt;背景色调整为RGB(199,237,204); Window-&gt;Preferences-&gt;General-&gt;Editors-&gt;Text Editors-&gt;Spelling-&gt;取消勾选”enable spell checking”; Window-&gt;Preferences-&gt;General-&gt;Project Natures-&gt;取消勾选”Automatically detect missing …”; Window-&gt;Preferences-&gt;General-&gt;Sartup and Shutdown-&gt;仅保留git UI; Window-&gt;Preferences-&gt;General-&gt;Workspace-&gt;Text file encoding-&gt;修改为UTF-8; Window-&gt;Preferences-&gt;Install/Update-&gt;Automatic Updates-&gt;取消勾选”Automatically find new …”; Window-&gt;Preferences-&gt;Java-&gt;Code Style-&gt;Code Templates-&gt;Comments-&gt;Types-&gt;修改为@author ${user} &lt;mailto:jmzc_top@aliyun.com&gt;; Window-&gt;Preferences-&gt;Java-&gt;Code Style-&gt;Code Templates-&gt;Code-&gt;去掉注释部分; Window-&gt;Preferences-&gt;Java-&gt;Code Style-&gt;Formatter-&gt;创建一个新的myself模板-&gt;然后去掉Comments选择卡中的JavaDoc和block comment格式化; Window-&gt;Preferences-&gt;Java-&gt;Editors-&gt;Content Assist-&gt;Auto activation triggers for java-&gt;修改为abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ.; Window-&gt;Preferences-&gt;Java-&gt;Editors-&gt;Content Assist-&gt;Advanced-&gt;取消勾选”Java Proposals(Code Recommenders)”; Window-&gt;Preferences-&gt;Java-&gt;Editors-&gt;Templates-&gt;可以修改预定义模板或者新建模板; Window-&gt;Preferences-&gt;Java-&gt;Installed JREs-&gt;修改JRE为安装的JDK; Window-&gt;Preferences-&gt;JavaScript-&gt;Code Style-&gt;Formatter-&gt;创建一个新的myself模板-&gt;然后去掉Comments选择卡中的JavaDoc和block comment格式化; Window-&gt;Preferences-&gt;JavaScript-&gt;Editors-&gt;Content Assist-&gt;Auto activation triggers for javascript-&gt;修改为abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ.; Window-&gt;Preferences-&gt;Maven-&gt;Installings-&gt;添加外部的maven安装目录-&gt;进行勾选; Window-&gt;Preferences-&gt;Maven-&gt;User Settings-&gt;User Settings选择外部settings文件路径; Window-&gt;Preferences-&gt;Server-&gt;Runtime Environment-&gt;Add-&gt;添加外部tomcat; Window-&gt;Preferences-&gt;Web-&gt;JSP Files-&gt;修改Encoding为UTF-8; sts插件(老版本地址推演) 在sts插件官网找到eclipse4.9.0的下载地址,如下： 123456分解：https://download.springsource.com/release/TOOLS/update (保留1)/3.9.9.RELEASE/e4.9/springsource-tool-suite (保留4)-3.9.9.RELEASE-e4.9.0-updatesite.zip (保留6) 在STS官网找到对应的Eclipse的版本的下载地址,如下 12345678分解：https://download.springsource.com/release/STS/3.9.6.RELEASE (保留2)/dist/e4.9 (保留3)/spring-tool-suite-3.9.6.RELEASE-e4.9.0 (保留5)-win32-x86_64.zip 推算sts插件其他版本的地址，只需知道STS的下载地址，然后安装保留序号进行拼接即可；如需要下载eclispe4.7.3a的sts插件： STS下载地址：https://download.springsource.com/release/STS/3.9.4.RELEASE/dist/e4.7/spring-tool-suite-3.9.4.RELEASE-e4.7.3a-win32-x86_64.zip 按照上面的推导规则，得到sts插件的离线下载包地址为：https://download.springsource.com/release/TOOLS/update/3.9.4.RELEASE/e4.7/springsource-tool-suite-3.9.4.RELEASE-e4.7.3a-updatesite.zip 下载安装 打开eclispe-&gt;Help-&gt;Install New Software-&gt;Add-&gt;Achieve-&gt;选择下载的压缩包-&gt;OK-&gt;选择带有IDE的4个进行安装（取消勾选下面的站点升级） 安装lombok 官网下载lombok.jar或者通过maven下载； 双击jar，在出现的界面选择eclispe根目录中的eclispe.exe，再点击install/update即可; uml插件 planUML安装 官网地址：http://plantuml.com/zh; Help-&gt;Install New Software-&gt;Add-&gt;添加地址(http://hallvard.github.io/plantuml )-&gt;全部安装即可; 下载Graphviz并安装; Window-&gt;Preferences-&gt;PlantUML-&gt;配置dot.exe的路径; Window-&gt;Show View-&gt;PlanUML; AmaterasUML安装 Help-&gt;Install New Software-&gt;Add-&gt;添加地址(https://takezoe.github.io/amateras-update-site/)-&gt;全部安装即可; eclipse手动安装插件 在eclipse根目录下建文件夹MyPlugins; 下载插件并解压得到包含features和plugins的文件夹XXX; 完成复制和建立文件夹的操作之后，如${eclipse_Home}\\MyPlugins\\XXX\\eclipse\\features和..\\plugins文件夹; 在eclipse_Home下建links文件夹,并建立一个p1_xxx.link文件,内容为path=${eclipse_Home}/MyPlugins/xxx 注意: 路径中是”/“或者”\\“ 而不是”&quot; ; ${eclipse_Home}换成实际绝对地址：如D:\\eclipse\\MyPlugins\\quantum303; link目录下的文件eclipse都要读入,小心！; path下面应该有eclipse文件夹，而不是将path设置成eclipse文件夹; 让path下面有plugins和features这两个目录; 删除${eclipse_Home}\\configuration中的org.eclipse.update目录; 重启eclipse,ok. 其实，myeclipse的插件安装就是如此操作的; eclispe注释模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364文件(Files)注释标签：/** * @Title: $&#123;file_name&#125;* @Package $&#123;package_name&#125;* @Description: $&#123;todo&#125;(用一句话描述该文件做什么)* @author A18ccms A18ccms_gmail_com * @date $&#123;date&#125; $&#123;time&#125;* @version V1.0 */类型(Types)注释标签（类的注释）：/*** @ClassName: $&#123;type_name&#125;* @Description: $&#123;todo&#125;(这里用一句话描述这个类的作用)* @author A18ccms a18ccms_gmail_com* @date $&#123;date&#125; $&#123;time&#125;** $&#123;tags&#125;*/字段(Fields)注释标签：/*** @Fields $&#123;field&#125; : $&#123;todo&#125;(用一句话描述这个变量表示什么)*/构造函数标签：/*** &lt;p&gt;Title: &lt;/p&gt;* &lt;p&gt;Description: &lt;/p&gt;* $&#123;tags&#125;*/方法(Constructor &amp; Methods)标签：/*** @Title: $&#123;enclosing_method&#125;* @Description: $&#123;todo&#125;(这里用一句话描述这个方法的作用)* @param $&#123;tags&#125; 设定文件* @return $&#123;return_type&#125; 返回类型* @throws*/覆盖方法(Overriding Methods)标签：/* (非 Javadoc)* &lt;p&gt;Title: $&#123;enclosing_method&#125;&lt;/p&gt;* &lt;p&gt;Description: &lt;/p&gt;* $&#123;tags&#125;* $&#123;see_to_overridden&#125;*/代表方法(Delegate Methods)标签：/*** $&#123;tags&#125;* $&#123;see_to_target&#125;*/getter方法标签：/*** @return $&#123;bare_field_name&#125;*/setter方法标签：/*** @param $&#123;param&#125; 要设置的 $&#123;bare_field_name&#125;*/","tags":[{"name":"eclipse","slug":"eclipse","permalink":"https://jmzc4j.github.io/tags/eclipse/"}]},{"title":"LogBack配置","date":"2019-08-28T10:51:03.000Z","path":"2019/08/28/LogBack配置/","text":"what is-Logback是由log4j创始人设计的另一个开源日志组件,[官方网站] (http://logback.qos.ch); 它当前分为下面几个模块： logback-core：其它两个模块的基础模块; logback-classic：它是log4j的一个改良版本，同时它完整实现了slf4jAPI使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging; logback-access：访问模块与Servlet容器集成提供通过Http来访问日志的功能; why use it 更快的实现：Logback的内核重写了，在一些关键执行路径上性能提升10倍以上。而且logback不仅性能提升了，初始化内存加载也更小了； 非常充分的测试：Logback经过了几年，数不清小时的测试。Logback的测试完全不同级别的； Logback-classic非常自然实现了SLF4j，在使用SLF4j中，你都感觉不到logback-classic； 非常充分的文档：官方网站有两百多页的文档； 自动重新加载配置文件：当配置文件修改了，Logback-classic能自动重新加载配置文件。扫描过程快且安全，它并不需要另外创建一个扫描线程； Filters（过滤器）：在log4j，只有降低日志级别，不过这样会打出大量的日志，会影响应用性能。在Logback，你可以继续保持那个日志级别； 自动压缩已经打出来的log：RollingFileAppender在产生新文件的时候，会自动异步压缩已经打出来的日志文件。 自动去除旧的日志文件：设置TimeBasedRollingPolicy或者SizeAndTimeBasedFNATP的maxHistory属性，你可以控制已经产生日志文件的最大数量； logback.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- scan: 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 scanPeriod: 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 debug: 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。--&gt;&lt;configuration debug=\"true\" scan=\"true\" scanPeriod=\"60 seconds\"&gt; &lt;!-- 上下文名称，用于区分不同应用程序的记录 默认default --&gt; &lt;contextName&gt;default&lt;/contextName&gt; &lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径 --&gt; &lt;property name=\"LOG_HOME\" value=\"./log\" /&gt; &lt;!-- 定义日志布局的转换样式 --&gt; &lt;!--格式化输出：%d表示日期，%p优先级，%c类全限定名，%M方法名，%L行号，%m日志信息，%n换行 --&gt; &lt;property name=\"layout_pattern\" value=\"%d&#123;yyyy-MM-dd HH:mm:ss&#125;[%p][%c][%M][%L] -&gt; %m%n\" /&gt; &lt;property name=\"layout_pattern2\" value=\"%date [%thread] %-5level %logger&#123;36&#125; [%line] - %msg%n\"/&gt; &lt;!-- 定义要保存的最大归档文件数量，异步删除旧文件 （需要结合滚动pattern具体分析） --&gt; &lt;property name=\"logFile_period\" value=\"30\" /&gt; &lt;!-- 定义单个日志文件的最大为10M 超出此大小则生成新文件 --&gt; &lt;property name=\"logFile_maxSize\" value=\"10MB\" /&gt; &lt;!-- 邮件参数设置 --&gt; &lt;!-- 定义邮件服务器地址 --&gt; &lt;property name=\"smtpHost\" value=\"smtp.163.com\" /&gt; &lt;!-- smtp端口 ，默认值25 --&gt; &lt;property name=\"smtpPort\" value=\"25\" /&gt; &lt;!-- 发件人用户名 --&gt; &lt;property name=\"username\" value=\"jmzc_top\" /&gt; &lt;!-- 发件人授权码 --&gt; &lt;property name=\"password\" value=\"grant163tojmzc\" /&gt; &lt;!-- 安全连接 默认false --&gt; &lt;property name=\"SSL\" value=\"false\" /&gt; &lt;!-- 收件人邮箱 --&gt; &lt;property name=\"email_to\" value=\"jmzc_top@aliyun.com\" /&gt; &lt;!-- 发件人邮箱 --&gt; &lt;property name=\"email_from\" value=\"jmzc_top@163.com\" /&gt; &lt;!-- 主题 默认%logger&#123;20&#125; - %m --&gt; &lt;property name=\"email_subject\" value=\"【Error】: %logger\" /&gt; &lt;!-- 输出日志到控制台 --&gt; &lt;appender name=\"Console\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;pattern&gt;$&#123;layout_pattern&#125;&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;!-- 过滤器，记录&gt;=DEBUG级别的日志 --&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 输入日志到文件 DEBUG级别 --&gt; &lt;appender name=\"FileDebug\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/debug.%d&#123;yyyyMMdd&#125;.zip&lt;/FileNamePattern&gt; &lt;MaxHistory&gt;$&#123;logFile_period&#125;&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;pattern&gt;$&#123;layout_pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;MaxFileSize&gt;$&#123;logFile_maxSize&#125;&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;/filter&gt; &lt;!-- 过滤器，只记录DEBUG级别的日志 --&gt; &lt;!-- &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; --&gt; &lt;/appender&gt; &lt;!-- 输入日志到文件 ERROR级别 --&gt; &lt;appender name=\"FileError\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 设置文件滚动的样式 %d&#123;yyyyMMdd&#125;表示每天滚动 或者达到最大文件大小后滚动 .gz | .zip | .log | .txt --&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/error.%d&#123;yyyyMMdd&#125;.zip&lt;/FileNamePattern&gt; &lt;MaxHistory&gt;$&#123;logFile_period&#125;&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;pattern&gt;$&#123;layout_pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;MaxFileSize&gt;$&#123;logFile_maxSize&#125;&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 输出日志到邮件 janino.jar和mail.jar --&gt; &lt;appender name=\"Email\" class=\"ch.qos.logback.classic.net.SMTPAppender\"&gt; &lt;!-- 基于标记和日志等级发送邮件 --&gt; &lt;evaluator class=\"ch.qos.logback.classic.boolex.JaninoEventEvaluator\"&gt; &lt;expression&gt; (level &gt; WARN &amp;amp;&amp;amp; null != throwable)||(marker != null &amp;amp;&amp;amp; marker.contains(\"DEVELOP\")) &lt;/expression&gt; &lt;/evaluator&gt; &lt;!-- 一个邮件只包含一个日志条目 --&gt; &lt;cyclicBufferTracker class=\"ch.qos.logback.core.spi.CyclicBufferTracker\"&gt; &lt;bufferSize&gt;1&lt;/bufferSize&gt; &lt;/cyclicBufferTracker&gt; &lt;!-- 设置同步发送，异步不好用？？？ --&gt; &lt;asynchronousSending&gt;false&lt;/asynchronousSending&gt; &lt;smtpHost&gt;$&#123;smtpHost&#125;&lt;/smtpHost&gt; &lt;smtpPort&gt;$&#123;smtpPort&#125;&lt;/smtpPort&gt; &lt;SSL&gt;$&#123;SSL&#125;&lt;/SSL&gt; &lt;username&gt;$&#123;username&#125;&lt;/username&gt; &lt;password&gt;$&#123;password&#125;&lt;/password&gt; &lt;to&gt;$&#123;email_to&#125;&lt;/to&gt; &lt;from&gt;$&#123;email_from&#125;&lt;/from&gt; &lt;subject&gt;$&#123;email_subject&#125;&lt;/subject&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;Pattern&gt;$&#123;layout_pattern&#125;&lt;/Pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- root是所有logger的祖先 --&gt; &lt;!-- 日志输出级别 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR --&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"Console\" /&gt; &lt;!-- &lt;appender-ref ref=\"FileDebug\" /&gt; &lt;appender-ref ref=\"FileError\" /&gt; &lt;appender-ref ref=\"Email\" /&gt; --&gt; &lt;/root&gt; &lt;!-- show parameters for hibernate sql 专为 Hibernate 定制 --&gt; &lt;logger name=\"org.hibernate.type.descriptor.sql.BasicBinder\" level=\"TRACE\" /&gt; &lt;logger name=\"org.hibernate.type.descriptor.sql.BasicExtractor\" level=\"DEBUG\" /&gt; &lt;logger name=\"org.hibernate.SQL\" level=\"DEBUG\" /&gt; &lt;logger name=\"org.hibernate.engine.QueryParameters\" level=\"DEBUG\" /&gt; &lt;logger name=\"org.hibernate.engine.query.HQLQueryPlan\" level=\"DEBUG\" /&gt; &lt;!--myibatis log configure--&gt; &lt;logger name=\"com.apache.ibatis\" level=\"TRACE\"/&gt; &lt;logger name=\"java.sql.Connection\" level=\"DEBUG\"/&gt; &lt;logger name=\"java.sql.Statement\" level=\"DEBUG\"/&gt; &lt;logger name=\"java.sql.PreparedStatement\" level=\"DEBUG\"/&gt;&lt;/configuration&gt; 附件配置文件","tags":[{"name":"logback","slug":"logback","permalink":"https://jmzc4j.github.io/tags/logback/"}]},{"title":"Log4j配置","date":"2019-08-28T10:49:24.000Z","path":"2019/08/28/Log4j配置/","text":"what is Log4j是Apache下的一款开源的日志框架;在项目中，我们会结合slf4j和log4j一起使用; Log4j提供了简单的API调用，强大的日志格式定义以及灵活的扩展性。我们可以自己定义Appender来满足我们对于日志输出的需求; Log4j有三个主要的组件：Loggers(记录器)，Appenders(输出源)和Layouts(布局); why use it 我们在系统中对于记录日志的需求并不单纯。首先，我们希望日志要能持久化到磁盘，最基本的就是要能够保存到文件中；其次，我们希望在开发和生产环境中记录的日志并不相同，明显开发环境的日志记录会更多方便调试，但放到生产环境下大量的日志很容易会撑爆服务器，因此在生产环境我们希望只记录重要信息。 基于不单纯的目的，System.out.println是直接不能满足我们的要求，因此抛弃它，选择功能更强的日志框架。而log4j是apache下一款著名的开源日志框架，log4j满足上面的一切需求。 记录日志的框架并不仅仅只有log4j，比较有名的还有logback等，现在比较火的SpringBoot默认集成的日志就是logback。不管哪种日志框架，一般都能够实现日志的持久化功能。 日志级别Loggers组件在此系统中被分为五个级别：DEBUG、INFO、WARN、ERROR和FATAL。这五个级别是有顺序的，DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，分别用来指定这条日志信息的重要程度，明白这一点很重要，Log4j有一个规则：只输出级别不低于设定级别的日志信息，假设Loggers级别设定为INFO，则INFO、WARN、ERROR和FATAL级别的日志信息都会输出，而级别比INFO低的DEBUG则不会输出。 输出格式说明：1234567891011121314151617%p：输出日志信息的优先级，即DEBUG，INFO，WARN，ERROR，FATAL。%d：输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，如：%d&#123;yyyy/MM/dd HH:mm:ss,SSS&#125;。%r：输出自应用程序启动到输出该log信息耗费的毫秒数。%t：输出产生该日志事件的线程名。%l：输出日志事件的发生位置，相当于%c.%M(%F:%L)的组合，包括类全名、方法、文件名以及在代码中的行数。例如：test.TestLog4j.main(TestLog4j.java:10)。%c：输出日志信息所属的类目，通常就是所在类的全名。%M：输出产生日志信息的方法名。%F：输出日志消息产生时所在的文件名称。%L:：输出代码中的行号。%m:：输出代码中指定的具体日志信息。%n：输出一个回车换行符，Windows平台为&quot;rn&quot;，Unix平台为&quot;n&quot;。%x：输出和当前线程相关联的NDC(嵌套诊断环境)，尤其用到像java servlets这样的多客户多线程的应用中。%%：输出一个&quot;%&quot;字符。另外，还可以在%与格式字符之间加上修饰符来控制其最小长度、最大长度、和文本的对齐方式。如：1) c：指定输出category的名称，最小的长度是20，如果category的名称长度小于20的话，默认的情况下右对齐。2)%-20c：&quot;-&quot;号表示左对齐。3)%.30c：指定输出category的名称，最大的长度是30，如果category的名称长度大于30的话，就会将左边多出的字符截掉，但小于30的话也不会补空格。 log4j.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE log4j:configuration PUBLIC \"-//log4j/log4j Configuration//EN\" \"log4j.dtd\"&gt;&lt;log4j:configuration&gt; &lt;!--输出到控制台--&gt; &lt;appender name=\"consoleAppender\" class=\"org.apache.log4j.ConsoleAppender\"&gt; &lt;param name=\"Threshold\" value=\"DEBUG\"/&gt; &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt; &lt;param name=\"ConversionPattern\" value=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!--输出到文件（info）--&gt; &lt;!--将生成“info.log.2014-06-11”这样的日志文件--&gt; &lt;appender name=\"fileAppenderInfo\" class=\"org.apache.log4j.DailyRollingFileAppender\"&gt; &lt;param name=\"File\" value=\"$&#123;user.home&#125;/logs/website/info.log\" /&gt; &lt;param name=\"DatePattern\" value=\".yyyy-MM-dd\" /&gt; &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt; &lt;param name=\"ConversionPattern\" value=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;/layout&gt; &lt;filter class=\"org.apache.log4j.varia.LevelRangeFilter\"&gt; &lt;param name=\"LevelMin\" value=\"INFO\" /&gt; &lt;param name=\"LevelMax\" value=\"INFO\" /&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!--输出到文件（warn）--&gt; &lt;appender name=\"fileAppenderWarn\" class=\"org.apache.log4j.DailyRollingFileAppender\"&gt; &lt;param name=\"File\" value=\"$&#123;user.home&#125;/logs/website/warn.log\" /&gt; &lt;param name=\"DatePattern\" value=\".yyyy-MM-dd\" /&gt; &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt; &lt;param name=\"ConversionPattern\" value=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;/layout&gt; &lt;filter class=\"org.apache.log4j.varia.LevelRangeFilter\"&gt; &lt;param name=\"LevelMin\" value=\"WARN\" /&gt; &lt;param name=\"LevelMax\" value=\"WARN\" /&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!--输出到文件（error）--&gt; &lt;appender name=\"fileAppenderError\" class=\"org.apache.log4j.DailyRollingFileAppender\"&gt; &lt;param name=\"File\" value=\"$&#123;user.home&#125;/logs/website/error.log\" /&gt; &lt;param name=\"DatePattern\" value=\".yyyy-MM-dd\" /&gt; &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt; &lt;param name=\"ConversionPattern\" value=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;/layout&gt; &lt;filter class=\"org.apache.log4j.varia.LevelRangeFilter\"&gt; &lt;param name=\"LevelMin\" value=\"ERROR\" /&gt; &lt;param name=\"LevelMax\" value=\"ERROR\" /&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!--屏蔽所有org.springframework.*输出的Debug（及以下）信息--&gt; &lt;logger name=\"org.springframework\"&gt; &lt;level value=\"INFO\"&gt;&lt;/level&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=\"ALL\"/&gt; &lt;appender-ref ref=\"consoleAppender\" /&gt; &lt;!-- &lt;appender-ref ref=\"fileAppenderInfo\" /&gt; &lt;appender-ref ref=\"fileAppenderWarn\" /&gt; &lt;appender-ref ref=\"fileAppenderError\" /&gt; --&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; log4j.properties123456789101112131415161718192021222324252627282930313233343536373839404142434445#默认输出路径log4j.rootLogger=info,stdout,logfile,busi1log4j.appender.logfile=org.apache.log4j.FileAppenderlog4j.appender.logfile.File=logs/cmsmgr.loglog4j.appender.logfile.layout=org.apache.log4j.PatternLayoutlog4j.appender.logfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %F %p %m%nlog4j.logger.com.ibatis=INFOlog4j.logger.com.ibatis.common.jdbc.SimpleDataSource=INFOlog4j.logger.com.ibatis.common.jdbc.ScriptRunner=INFOlog4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=INFOlog4j.logger.java.sql.Connection=INFOlog4j.logger.java.sql.Statement=INFOlog4j.logger.java.sql.PreparedStatement=INFO#输出到控制台log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.Threshold=INFOlog4j.appender.stdout.ImmediateFlush=truelog4j.appender.stdout.Target=System.errlog4j.appender.stdout.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n#输出到busi1log4j.logger.busi1= info, busi1#每天产生一个日志文件log4j.appender.busi1=org.apache.log4j.DailyRollingFileAppender#日志文件格式log4j.appender.busi1.DatePattern=&apos;.&apos;yyyy-MM-dd-HH#日志路径log4j.appender.busi1.File=logs/busi1.log#最低输出日志级别log4j.appender.busi1.Threshold = INFO#输出的布局样式log4j.appender.busi1.layout=org.apache.log4j.PatternLayout#自定义输出哪些信息log4j.appender.busi1.layout.ConversionPattern=[%d&#123;yyyy-MM-dd HH:mm:ss&#125;] %l%t %m%n#输出到busilog4j.logger.busi= info, busilog4j.appender.busi=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.busi.File=logs/busi.loglog4j.appender.busi.Threshold = INFOlog4j.appender.busi.DatePattern=&apos;.&apos;yyyy-MM-dd-HHlog4j.appender.busi.layout=org.apache.log4j.PatternLayoutlog4j.appender.busi.layout.ConversionPattern=[%d&#123;yyyy-MM-dd HH:mm:ss&#125;] %l%t %m%n 附件properties版 xml版","tags":[{"name":"log4j","slug":"log4j","permalink":"https://jmzc4j.github.io/tags/log4j/"}]},{"title":"Mybatis逆向工程配置","date":"2019-08-28T10:46:27.000Z","path":"2019/08/28/Mybatis逆向工程配置/","text":"what is mybatis逆向工程，就是mybatis会根据我们设计好的数据表，自动生成pojo、mapper以及mapper.xml； 官方文档：generator; generateConfig.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;!--导入属性配置--&gt; &lt;properties resource=\"generatorConfig.properties\" /&gt; &lt;!--指定特定数据库的jdbc驱动jar包的位置--&gt; &lt;classPathEntry location=\"$&#123;db.driverLocation&#125;\" /&gt; &lt;!-- targetRuntime=\"MyBatis3\"：选择运行的mybatis版本 ;如果你希望不生成和Example查询有关的内容,可以使用MyBatis3Simple--&gt; &lt;!-- defaultModelType=\"flat\" :这种类型的model会为每个表生成唯一的一个类，这个类中会包含表中所有的字段 ;默认值conditional --&gt; &lt;context id=\"default\" targetRuntime=\"MyBatis3\" defaultModelType=\"flat\"&gt; &lt;!-- 在创建class时，对注释进行控制 --&gt; &lt;commentGenerator&gt; &lt;!-- 阻止生成注释，默认为false --&gt; &lt;property name=\"suppressAllComments\" value=\"true\" /&gt; &lt;/commentGenerator&gt; &lt;!--jdbc的数据库连接 --&gt; &lt;jdbcConnection driverClass=\"$&#123;jdbc.driverClass&#125;\" connectionURL=\"$&#123;jdbc.jdbcUrl&#125;\" userId=\"$&#123;jdbc.user&#125;\" password=\"$&#123;jdbc.password&#125;\"&gt; &lt;/jdbcConnection&gt; &lt;!-- 是否强制DECIMAL和NUMERIC类型的字段转换为Java类型的java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=\"forceBigDecimals\" value=\"false\" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类 --&gt; &lt;javaModelGenerator targetPackage=\"$&#123;pojoTargetPackage&#125;\" targetProject=\"$&#123;targetProject&#125;\"&gt; &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt; &lt;property name=\"enableSubPackages\" value=\"false\" /&gt; &lt;!-- 是否对model添加 构造函数 --&gt; &lt;property name=\"constructorBased\" value=\"true\" /&gt; &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt; &lt;property name=\"trimStrings\" value=\"true\" /&gt; &lt;!-- 建立的Model对象是否不可改变 即生成的Model对象不会有 setter方法，只有构造方法 --&gt; &lt;property name=\"immutable\" value=\"false\" /&gt; &lt;/javaModelGenerator&gt; &lt;!--mapper xml映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt; &lt;sqlMapGenerator targetPackage=\"$&#123;xmlTargetPackage&#125;\" targetProject=\"$&#123;xmlTargetProject&#125;\"&gt; &lt;property name=\"enableSubPackages\" value=\"false\" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- type=\"XMLMAPPER\" 接口和XML完全分离，接口中不出现SQL语句, 修改SQL不需要重新编译 (推荐使用) type=\"ANNOTATEDMAPPER\",生成Java Model 和基于注解的Mapper对象 type=\"MIXEDMAPPER\",生成基于注解的Java Model 和相应的Mapper对象 --&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"$&#123;mapperTargetPackage&#125;\" targetProject=\"$&#123;targetProject&#125;\"&gt; &lt;property name=\"enableSubPackages\" value=\"false\" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 生成全部的表 tableName=\"%\" --&gt; &lt;table tableName=\"EMP\" domainObjectName=\"Emp\"&gt; &lt;!-- generatedKey：用来指定生成的主键 会在Insert语句中添加 selectKey标签 --&gt; &lt;generatedKey column=\"EMPNO\" sqlStatement=\"MySql\" /&gt; &lt;/table&gt; &lt;table tableName=\"DEPT\" domainObjectName=\"Dept\"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 附件generatorConfig.properties generatorConfig.xml","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://jmzc4j.github.io/tags/mybatis/"}]},{"title":"MySQL常用配置","date":"2019-08-28T10:41:59.000Z","path":"2019/08/28/MySQL常用配置/","text":"my.cnf常用配置[client]#password = your_passwordport = 3306 #端口设置socket = /tmp/mysql.sock #本地客户端通讯需要使用的套接字文件，需要保护起来default-character-set=utf-8 #客户端默认字符集 [mysqld]lower_case_table_names=1 #设置表名一律转小写，即大小写不敏感设置，Linux下默认是0port = 3306 #服务器端口basedir=”/usr/local/mysql” #设置mysql的安装目录datadir=”/usr/local/mysql/data” #设置mysql数据库的数据的存放目录default-storage-engine=INNODB #创建新表时将使用的默认存储引擎socket = /tmp/mysql.sock #服务器与本地客户端通讯的套接字文件位置character-set-server=utf-8 #服务端使用的字符集max_connections=100 #服务器支持的最大并发连接数query_cache_size=0 #缓存查询结果的缓存大小table_cache=256 #为所有线程打开的表的数量tmp_table_size=35M #内存中的每个临时表允许的最大大小thread_cache_size=8 #缓存的最大线程数 #MyISAM相关参数myisam_max_sort_file_size=100G #重建索引时允许使用的临时文件最大大小myisam_sort_buffer_size=68M #快速创建索引的临时文件的缓冲区大小key_buffer_size=54M #缓存MyISAM表索引块的缓冲区大小，不要把它设置得超过可用内存的30%read_buffer_size=64K #全表扫描时使用的缓冲区大小read_rnd_buffer_size=256K #执行全表扫描的缓冲区的大小sort_buffer_size=256K #重建索引时为每个线程分配的缓冲区大小 #InnoDB相关参数innodb_additional_mem_pool_size=34M #存储元数据信息的额外内存池大小，一般不需修改innodb_flush_log_at_trx_commit =1 #事务提交频率，1表示每次都直接写入磁盘，不写入内存，更符合ACID的行为；其他值还有0和2，不推荐innodb_log_buffer_size=2M #缓冲日志数据的缓冲区大小，一旦已经满了，InnoDB必须把它刷新到磁盘上。innodb_buffer_pool_size=105M #缓存索引和行数据的缓冲池大小，一般将该值设为物理内存的80%innodb_log_file_size=53M #日志组中每个日志文件的大小。一般设为innodb_buffer_pool_size的25%到100%innodb_thread_concurrency=10 #允许连接INNODB内核的最大并发线程数量 #SQL模式为严格模式sql-mode=”STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION” 附件配置文件 druid常用配置","tags":[{"name":"mysql","slug":"mysql","permalink":"https://jmzc4j.github.io/tags/mysql/"}]},{"title":"常用数据库的参数配置","date":"2019-08-28T10:37:28.000Z","path":"2019/08/28/常用数据库的参数配置/","text":"JDBC的URLJDBC的URL＝协议名＋子协议名＋数据源名。协议名总是“jdbc”。子协议名由JDBC驱动程序的编写者决定。数据源名也可能包含用户与口令等信息；这些信息也可单独提供。 mysqlmysql.driver=com.mysql.jdbc.Drivermysql.url=jdbc:mysql://192.168.157.130:3306/mybatis01?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=falsemysql.username=rootmysql.password=root oracleoracle.driver=oracle.jdbc.driver.OracleDriveroracle.url=jdbc:oracle:thin:@127.0.0.1:1521:xeoracle.username=systemoracle.password=abc123 sql serversqlServer.driver=com.microsoft.sqlserver.jdbc.SQLServerDriversqlServer.url=jdbc:sqlserver://localhost:1433;DatabaseName=mydbsqlServer.username=sasqlServer.password=123 附件db-properties文件","tags":[{"name":"database","slug":"database","permalink":"https://jmzc4j.github.io/tags/database/"}]},{"title":"Mybatis常用配置","date":"2019-08-28T10:23:58.000Z","path":"2019/08/28/Mybatis常用配置/","text":"what is MyBatis 是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射;避免了几乎所有的JDBC 代码和手动设置参数以及获取结果集; MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects)映射成数据库中的记录; 官方文档：mybatis; mybatis-config.xml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 在配置文件中，属性的加载有三种方式： 1. resource或者url引入外部资源； 2. 在properties标签中使用property子标签进行定义，然后使用表达式引用； 3. 直接在要使用的位置硬编码； 注意：以上三种方式的优先级从低到高； --&gt; &lt;properties resource=\"mybatis/db.properties\" /&gt; &lt;!-- 全局配置信息 logImpl：mybatis日志的实现； cacheEnabled：二级缓存开关； lazyLoadingEnabled：懒加载开关； aggressiveLazyLoading：积极懒加载开关，当懒加载时是否主动进行属性的初始化； mapUnderscoreToCamelCase：数据库列映射Java对象属性开关； useActualParamName：参数命名开关； --&gt; &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"slf4j\"/&gt; &lt;setting name=\"cacheEnabled\" value=\"true\" /&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\" /&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\" /&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;setting name=\"useActualParamName\" value=\"true\"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- 以包扫描的方式进行别名定义，默认类名首字母小写（注意别名其实是不区分大小写的）； 当子包有相同的 类名存在时，可以使用@Alias注解进行签名； --&gt; &lt;package name=\"top.jmzc.pojo\"/&gt; &lt;/typeAliases&gt; &lt;plugins&gt; &lt;!-- 插件配置：以AOP的方式对Executor、MappedStatement、ParameterHandler、ResultSetHandler四大对象的方法进行拦截； 自定义插件的步骤： 1. 实现Intercept接口，逐一实现setProperties()、plugin()和intercept()方法； 2. 为定制的插件进行签名，使用@@Intercepts注解； 3. 在mybatis配置文件中进行声明； pagehelper5中可以自动配置dialect，当进行定制配置时，dialect的值一定是全类名，源码中发现使用dialectClass进行反射 --&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;!-- &lt;property name=\"dialect\" value=\"com.github.pagehelper.dialect.helper.MySqlDialect\"/&gt; --&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;environments default=\"dev_mysql\"&gt; &lt;!-- 配置Session的环境，可以有多个环境，通过environments标签的default属性来切换； transactionManager：需要指定事务工厂的类型，这里使用的是别名，也可以实现ibatis提供的接口来进行定制； dataSource：需要指定数据源工厂的类型，同样使用的是别名，同样可以实现ibatis提供的接口进行定制； --&gt; &lt;environment id=\"dev_mysql\"&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;mysql.driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;mysql.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;mysql.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;mysql.password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 为不同的数据库厂商的ProductName设置别名； ProductName可以从Connection接口的MetaData中得到； --&gt; &lt;databaseIdProvider type=\"DB_VENDOR\"&gt; &lt;property name=\"MySQL\" value=\"mysql\"/&gt; &lt;property name=\"Oracle\" value=\"oracle\"/&gt; &lt;property name=\"SQL Server\" value=\"sqlserver\"/&gt; &lt;/databaseIdProvider&gt; &lt;mappers&gt; &lt;!-- 指定映射文件的包路径 --&gt; &lt;package name=\"top.jmzc.mapper\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 附件 l","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://jmzc4j.github.io/tags/mybatis/"}]},{"title":"Redis常用配置","date":"2019-08-28T10:19:39.000Z","path":"2019/08/28/Redis常用配置/","text":"redis.cof常见配置说明 Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程daemonize no 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定pidfile /var/run/redis.pid 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字port 6379 绑定的主机地址bind 127.0.0.1 当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能timeout 300 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verboseloglevel verbose 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/nulllogfile stdout 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库iddatabases 16 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合saveRedis默认配置文件中提供了三个条件：save 900 1save 300 10save 60 10000分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大rdbcompression yes 指定本地数据库文件名，默认值为dump.rdbdbfilename dump.rdb 指定本地数据库存放目录dir ./ 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步slaveof 当master服务设置了密码保护时，slav服务连接master的密码masterauth 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭requirepass foobared 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息maxclients 128 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区maxmemory 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为noappendonly no 指定更新日志文件名，默认为appendonly.aofappendfilename appendonly.aof 指定更新日志条件，共有3个可选值：no：表示等操作系统进行数据缓存同步到磁盘（快）always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）everysec：表示每秒同步一次（折衷，默认值）appendfsync everysec 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）vm-enabled no 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享vm-swap-file /tmp/redis.swap 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0vm-max-memory 0 Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值vm-page-size 32 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。vm-pages 134217728 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4vm-max-threads 4 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启glueoutputbuf yes 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法hash-max-zipmap-entries 64hash-max-zipmap-value 512 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）activerehashing yes 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件include /path/to/local.conf 附件未改动过的配置文件","tags":[{"name":"redis","slug":"redis","permalink":"https://jmzc4j.github.io/tags/redis/"}]},{"title":"Docker入门","date":"2019-08-28T09:09:05.000Z","path":"2019/08/28/Docker入门/","text":"what is Docker是一个容器管理引擎，是一个轻量级的虚拟化技术；从镜像和容器的角度来定义一个应用； 将应用代码和配置等打包成一个可运行的环境（image），从而实现开发和生产环境的完美对接，达到一种一次构建到处运行的目的； repository、image、container为其最重要的三个组成部分。 image是由一层一层的文件系统组成，即UnionFS；其最底层是bootfs； image都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部；这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。 通过容器数据卷来实现数据持久化和数据共享； 安装与卸载 centos安装步骤 ①卸载旧版本 12345678$sudo yum remove docker \\docker-client \\docker-client-latest \\docker-common \\docker-latest \\docker-latest-logrotate \\docker-logrotate \\docker-engine ②安装依赖包 123$sudo yum install -y yum-utils \\device-mapper-persistent-data \\lvm2 ③配置仓库地址（这里使用阿里巴巴的国内镜像） 123456$sudo yum-config-manager \\ --add-repo \\https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo#这里可以清理yum缓存文件$yum makecache fast ④安装最新版或者自行选择版本 123456789#列出docker引擎的可用版本$yum list docker-ce --showduplicates | sort -r#选择版本进行安装#例如查到docker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stable#那么VERSION_STRING就是 docker-ce-18.09.1$sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io#也可以直接安装最新版$sudo yum install docker-ce docker-ce-cli containerd.io ⑤启动 1$sudo systemctl start docker ⑥测试 123$ sudo docker run hello-world或者执行docker version ⑦配置阿里云的镜像加速 123456789登录阿里云进入控制台，搜索容器镜像服务点击镜像加速器，然后找到centos的配置信息，按步骤配置即可vi /etc/docker/daemon.json#这里的镜像ID（u7dhnsts）不同人会不同&#123;&quot;registry-mirrors&quot;: [&quot;https://u7dhnsts.mirror.aliyuncs.com&quot;] &#125;sudo systemctl daemon-reloadsudo systemctl restart docker 卸载 12$ sudo yum remove docker-ce$ sudo rm -rf /var/lib/docker docker命令 docker --help|docker &lt;command&gt; --help：查看帮助 docker images ：查看镜像列表； docker rmi -f $(docker images -qa)：删除多个镜像； docker ps；查看正在运行的容器； docker rm -f $(docker ps -qa)：删除所有的容器； docker run &lt;containerName|containerID&gt; ：在镜像上创建一个容器（本地没有则会自动去远程仓库拉去）； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 OPTIONS说明（常用）：有些是一个减号，有些是两个减号 --name=&quot;容器新名字&quot;: 为容器指定一个名称； -d: 后台运行容器，并返回容器ID，也即启动守护式容器； -i：以交互模式运行容器，通常与 -t 同时使用； -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用； -P: 随机端口映射； -p: 指定端口映射，有以下四种格式 ip:hostPort:containerPort ip::containerPort hostPort:containerPort containerPort ``` 1. `docker search &lt;imageName:tag&gt;`：在仓库上搜索镜像，默认latest；1. `docker pull &lt;imageName:tag&gt;`：从远程拉取镜像到本地；1. `docker exec -it /bin/bash`：进入正在运行的容器；1. `docker commit -m &quot;xxx&quot; -a &quot;xxx&quot; &lt;containerName|containerID&gt; targetImage:tag`：基于容器生成一个新的镜像；1. `docker inspect &lt;containerName|containerID&gt;`：查看容器的详细信息；1. `docker info | docker version`：查看docker的简单信息；1. `docker logs -f &lt;containerName|containerID&gt;`：查看一个容器的历史记录1. `docker start|stop|restart &lt;containerName|containerID&gt;`：启动、停止、重启容器；1. `docker kill &lt;containerName|containerID&gt;`：强制停止容器；1. `docker cp containerID:path hostPath`：从容器拷贝文件到主机；1. `docker build -t 新镜像名字:TAG `：从Dockerfile中创建镜像；1. `docker history 镜像名`：查看镜像的变更历史；### Dockerfile- Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本；- Dockerfile约定1. 每条保留字指令都必须为大写字母且后面要跟随至少一个参数；2. 指令按照从上到下，顺序执行；3. 每条指令都会创建一个新的镜像层，并对镜像进行提交；- Dockerfile大致流程1. docker从基础镜像运行一个容器；2. 执行一条指令并对容器作出修改；3. 执行类似docker commit的操作提交一个新的镜像层；4. docker再基于刚提交的镜像运行一个新容器；5. 执行dockerfile中的下一条指令直到所有指令都执行完成；- Dockerfile中的关键字1. `FROM`：基础镜像，当前新镜像是基于哪个镜像的；1. `MAINTAINER`：镜像维护者的姓名和邮箱地址；1. `RUN`：容器构建时需要运行的命令；1. `EXPOSE`：当前容器对外暴露出的端口；1. `WORKDIR`：指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点；1. `ENV`：用来在构建镜像过程中设置环境变量；1. `ADD`：将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包；1. `COPY`：类似ADD，拷贝文件和目录到镜像中；但不进行解压；1. `VOLUME`：容器数据卷，用于数据保存和持久化工作；1. `CMD`：指定一个容器启动时要运行的命令；多个CMD会被覆盖；CMD 会被 docker run 之后的参数替换；1. `ENTRYPOINT`：ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数，以追加的方式执行；1. `ONBUILD`：当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发；- 自定义tomcat9 FROM centos MAINTAINER zzyy #把宿主机当前上下文的c.txt拷贝到容器/usr/local/路径下 COPY c.txt /usr/local/cincontainer.txt #把java与tomcat添加到容器中 ADD jdk-8u171-linux-x64.tar.gz /usr/local/ ADD apache-tomcat-9.0.8.tar.gz /usr/local/ #安装vim编辑器 RUN yum -y install vim #设置工作访问时候的WORKDIR路径，登录落脚点 ENV MYPATH /usr/local WORKDIR $MYPATH #配置java与tomcat环境变量 ENV JAVA_HOME /usr/local/jdk1.8.0_171 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.8 ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.8 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin #容器运行时监听的端口 EXPOSE 8080 #启动时运行tomcat ENTRYPOINT [“/usr/local/apache-tomcat-9.0.8/bin/startup.sh” ]CMD [“/usr/local/apache-tomcat-9.0.8/bin/catalina.sh”,”run”] CMD /usr/local/apache-tomcat-9.0.8/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.8/bin/logs/catalina.out 1### docker安装mysql5.7 docker run -d –name mysql-5.7 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /usr/local/mysql/data:/var/lib/mysql -v /usr/local/mysql/my.cnf:/etc/mysql/my.cnf -v /usr/local/mysql/conf.d:/etc/mysql/conf.d -v /usr/local//mysql/mysql.conf.d:/etc/mysql/mysql.conf.d -v /usr/local/mysql/log:/var/log/mysql –privileged=true mysql:5.7","tags":[{"name":"docker","slug":"docker","permalink":"https://jmzc4j.github.io/tags/docker/"}]},{"title":"Git入门","date":"2019-08-28T09:03:45.000Z","path":"2019/08/28/Git入门/","text":"what is git 是一个免费开源的分布式版本控制工具； 书籍-Pro Git：有关git的一切可阅读此书获取； why use it 既可以进行本地版本控制，又可以进行分布式版本控制； 不存在集中式版本控制工具的单点故障问题； 具有强大的分支管理； 由于是Linus开发，天然可以使用Linux命令； Git分支 假设有三个目录，并做了提交; 12$ git add README test.rb LICENSE$ git commit -m &apos;The initial commit of my project&apos; Git会对每个子目录进行校验，并将它们作为树对象存储在Git存储库中;然后Git创建一个提交对象，该对象具有元数据和指向根项目树的指针，因此它可以在需要时重新创建该快照。 ; 如果进行一些更改并再次提交，则下一个提交会存储指向紧接其之前的提交的指针。 ； Git中的一个分支只是一个指向其中一个提交的轻量级可移动指针。Git中的默认分支名称是master。当你开始提交时，你会得到一个master指向你最后一次提交的分支。每次提交时，master分支指针都会自动向前移动。 ; Git中的“主”分支不是特殊分支。它与任何其他分支完全一样。几乎每个存储库都有一个的唯一原因是该git init命令默认创建它，并且大多数人都不愿意更改它。 how to use it 安装 Linux说明; macOS下载地址; Windows下载地址; 首次配置 1234567# 安装Git时应该做的第一件事是设置用户名和电子邮件地址# --system：指定系统级别，--global：指定用户级别$ git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com# 使用以下方法查看所有设置及其来源$ git config --list --show-origin 获取帮助 123456$ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt;# 如果您不需要完整的联机帮助页面帮助，但只需要快速了解Git命令的可用选项，您可以使用-h或--help,如：$ git add -h 常用命令 $ git init：在现有目录中初始化存储库； $ git add xxx：将xxx文件从工作区添加到暂存区；untrace-stage； $ git commit -m &#39;initial project version&#39;：从暂存区永久提交到当前分支；stage-unmodified； $ git clone https://github.com/libgit2/libgit2 mylibgit：克隆存储库到本地并修改存储库的目录名； $ git status：查看文件状态，主要查看文件内容是否发生了变化； $ git diff：查看工作区与暂存区的更改； $ git diff --cached：查看暂存区与上次提交的更改； $ git log [--pretty=oneline]：查看提交历史，用于回退过去； $ git reflog：查看命令历史，用于追溯未来； $ git reset --hard commitID：切换版本； $ git rm --cached README：删除暂存区文件； $ git checkout xxx：同步到工作区； $ git commit --amend：重做提交； $ git remote -v：查看远程时要使用的短名称存储的URL； $ git remote add &lt;shortname&gt; &lt;url&gt;：为远程库添加一个新的短名称； $ git fetch &lt;remote&gt;：从远处库抓取数据； $ git push &lt;remote&gt; &lt;branch&gt;：推送当前分支到远程库 $ git remote rename pb paul：更改远程库别名pb为paul； $ git remote remove paul：删除一个远程库url； $ git push &lt;remote&gt;：抓取并合并到本地； $ git branch testing：创建一个testing分支； $ git checkout testing:切换分支； $ git merge hotfix：合并hotfix分支到当前分支上； $ git branch -d hotfix：删除分支； $ git branch -v：查看每个分支上的最后一次提交； $ git branch --merged：查看已经合并了的分支，不带星号的分支可以删除； $ git push &lt;remote&gt; &lt;branch&gt;：将本地分支推送到一个名称不同的远程分支； $ git checkout -b sf origin/serverfix：设置名称与远程分支不同的本地分支； git branch -u origin/serverfix：更新当前分支为远程分支； $ git push origin --delete serverfix：完成合并删除远程分支； 参考文献 书籍-Pro Git; 博客园-Git命令总结; 廖雪峰-Git教程; 附件gitignore配置","tags":[{"name":"git","slug":"git","permalink":"https://jmzc4j.github.io/tags/git/"}]},{"title":"Redis命令","date":"2019-08-28T09:01:17.000Z","path":"2019/08/28/Redis命令/","text":"what is Redis全称为 Remote Dictionary Server; Redis是一个遵守BSD协议的开源的基于内存的数据结构存储服务；可以用做数据库、缓存和消息中间件；（官方） Redis是意大利人用C语言编写的一个高性能的（key/value）分布式的NoSQL数据库，支持多种数据类型并支持持久化； how to use it通用命令 dbsize select dbIndex flushdb flushall keys * exists key move key dbIndex expire key：设置key的存活时间（秒单位） ttl key：查看key的剩余存活时长，返回值含义（-1，永恒；-2，过期），过期就会被从内存中删除该key persist key：去掉有效期设置 type key string 常用 set/get/del/append/strlen key incr/decr key incrby/decrby key increment getrange/setrange key startIndex endIndex：获取key对应的指定范围的value，第一个索引为0，最后一个索引为-1 setex(with expire) key second value setnx(if not exist) key value mset/mget/msetnx key ：添加、获取多个kv getset list 常用 lpush/rpush/lrange lpop/rpop lIndex key lrem key count value ltrim key start end ；截取start到end的元素再赋值给原来的key rpoplpush srcList targetList：当scr与target相同就构成了一个循环 lInsert key before/after v1 v2 lset key index value set 常用 sadd smembers key sismember key v1 scard：获取元素个数 srem key value srandmember key num：随机取出num个元素 spop key smove key1 key2 value-in-key1：将key1中的某个值移动到key的集合中 sdiff key1 key2：获取在key1集合但不在key2集合的元素 sinter key1 key2 sunion key1 key2 hash 常用 hset/hget/hdel/hmset/hmget/hgetall hlen hexists key in-key hkeys/hvals hincrby/hincrbyfloat hsetnx zset 常用 zadd/zrange：zadd zset1 60 v1 70 v2 80 v3 90 v4 100 v5 zrangebyscore key startScore endScore：默认取左闭右闭区间，可以使用左小括号来更改为开区间 zcard/zcount key score1 score2 zrank key value：获取value在key集合中的排名，即获取下标 zscore key value zrevrange zrevrank key value zrevrangebyscore key endScore startScore","tags":[{"name":"redis","slug":"redis","permalink":"https://jmzc4j.github.io/tags/redis/"}]},{"title":"Maven入门","date":"2019-08-28T08:40:39.000Z","path":"2019/08/28/Maven入门/","text":"what is maven 是 apache软件基金会的一个产品； maven 是一个将模型应用于工程的管理系统； maven 是 一个Java项目的构建和管理工具，包括项目生命周期的管理和项目依赖的管理； why use it 简化项目构建，缩短了开发周期； 将代码与架包分离，仅仅在POM中提供依赖的引用即可； 统一的目录结构和约定，有利于开发者理解开发原则； how to config it 配置本地仓库路径 12345&lt;settings&gt; ... &lt;localRepository&gt;D:\\Repository\\mvnRepo&lt;/localRepository&gt; ...&lt;/settings&gt; 配置远程镜像仓库 123456789101112&lt;settings&gt; ... &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt;...&lt;/settings&gt; 配置JDK版本（也可以使用编译插件） 12345678910111213141516171819&lt;settings&gt; ... &lt;profiles&gt; &lt;!--定义工程的JDK版本--&gt; &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeteByDefault&gt;true&lt;/activeteByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; ...&lt;/settings&gt; how to use it maven的基本工作单元就是POM，POM中包含着项目的部分描述信息，所有的maven操作都是从POM开始的； maven的指令代表着生命周期中的不同阶段，这些指令仅仅是一个抽象层的定义，真实的操作都有由相应的插件来处理的； maven项目创建,使用原型（模板）创建不同的项目，过程中默认选择模板7（快速版）和默认1.0-snapshot版本； 1234mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DgroupId=com.mycompany.app -DartifactId=my-app 创建结果如下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- 指定模型的版本，一般不会变，统一版本可以确保稳定性 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 指定坐标和打包方式： groupId：组织和项目唯一标识； artifactId：工程基础名称； version：版本号和类型； packaging：打包方式，默认jar，同时约束了生命周期的最终阶段； --&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- Maven生成的文档相关： name:项目的显示名称; url:项目站点的位置; description:项目的基本描述; --&gt; &lt;name&gt;my-app&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;！-- 自定义的属性，EL方式引用 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 目录结构如下：(使用IDE创建的还会有resource目录) 123456789101112131415my-app|-- pom.xml`-- src |-- main | `-- java | `-- com | `-- mycompany | `-- app | `-- App.java `-- test `-- java `-- com `-- mycompany `-- app `-- AppTest.java 其他maven指令： mvn compile：编译源代码； mvn test：编译测试源代码并指定命名约定的单元测试； mvn test-compile：仅编译吃源代码； mvn package：打包到target目录中； mvn install：打包到本地仓库中； mvn site：生成项目的web站点； mvn clean：清理target的目录； mvn eclipse:eclipse：生成eclispe项目； mvn idea:idea：生成idea项目； mvn eclipse:clean：清楚eclispe配置； mvn dependency:list：列出所有依赖； mvn deploy：上传到私服； mvn test -skipping compile -skipping test-compile：不编译仅测试； mvn -version/-v：查看maven版本； mvn jetty:run：jetty上运行； mvn -e：显示错误信息； mvn validate：验证工程是否正确，所有需要的资源是否可用； mvn verify：运行任何检查，验证包是否有效且达到质量标准； mvn dependency:tree：输出依赖树； mvn tomcat:run：在tomcat6上运行； mvn help:describe -Dplugin=pluginName -Dgoal(或-Dmojo)=goalName：列出某个插件的goal信息； mvn tomcat7:run -Dmaven.test.skip=true：跳过测试； mvn eclipse:eclipse -DskipTests：生成导入Eclipse中的项目列表。一般在项目导入之前使用； mvn install:install-file -DgroupId=com -DartifactId=client -Dversion=0.1.0 -Dpackaging=jar -Dfile=d:\\client-0.1.0.jar：打包jar到本地库； 其他配置 如何发布jar到远程仓库1234567&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;mycompany-repository&lt;/id&gt; &lt;name&gt;MyCompany Repository&lt;/name&gt; &lt;url&gt;scp://repository.mycompany.com/repository/maven2&lt;/url&gt; &lt;/repository&gt;&lt;/distributionManagement&gt; 12345678910111213141516&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; ... &lt;servers&gt; &lt;server&gt; &lt;id&gt;mycompany-repository&lt;/id&gt; &lt;username&gt;jvanzyl&lt;/username&gt; &lt;!-- Default value is ~/.ssh/id_dsa --&gt; &lt;privateKey&gt;/path/to/identity&lt;/privateKey&gt; (default is ~/.ssh/id_dsa) &lt;passphrase&gt;my_key_passphrase&lt;/passphrase&gt; &lt;/server&gt; &lt;/servers&gt; ...&lt;/settings&gt; 编译插件 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 测试插件: 123456789&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.18.1&lt;/version&gt; &lt;!-- 同样实现跳过生命周期中的测试阶段 --&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt;&lt;/plugin&gt; 资源文件插件 1234567891011121314151617181920212223242526272829303132333435&lt;project&gt; ... &lt;build&gt; ... &lt;resources&gt; &lt;!-- 资源插件默认行为只是将项目主资源文件复制到主代码编译输出目录中，将测试资源文件复制到测试代码编译输出目录中。 --&gt; &lt;resource&gt; &lt;!-- 指定资源文件目录 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- 开启资源过滤 ：（默认false） filtering：作用是用环境变量，pom文件里定义的属性和指定文件里的属性替换属性文件的占位符。 --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;!-- includes之中的也会被过滤 --&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;!-- excludes之外的不会被过滤 --&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.xml&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; ... &lt;/resources&gt; ... &lt;/build&gt; ... &lt;/project&gt; mybatis逆向工程插件 1234567891011&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt;&lt;/plugin&gt;goal：mybatis-generator:generate tomcat插件 123456789101112131415161718&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/&lt;/path&gt; &lt;port&gt;8080&lt;/port&gt; &lt;server&gt;tomcat7&lt;/server&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 123456789101112&lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;tomcat-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/wp&lt;/path&gt; &lt;port&gt;8080&lt;/port&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;url&gt;http://localhost:8080/manager/html&lt;/url&gt; &lt;server&gt;tomcat6&lt;/server&gt; &lt;/configuration&gt;&lt;/plugin&gt; Maven中的属性 内置属性： ${basedir}：项目的根目录(包含pom.xml文件的目录； ${version}：项目版本； POM属性： ${project.build.sourceDirectory}：项目的主源码目录，默认为src/main/java； ${project.build.testSourceDirectory}：项目的测试源码目录，默认为src/test/java； ${project.build.directory}：项目构件输出目录，默认为target/； ${project.outputDirectory}：项目主代码编译输出目录，默认为target/classes/； ${project.testOutputDirectory}：项目测试代码编译输出目录，默认为target/test-classes/； ${project.groupId}：项目的groupId； ${project.artifactId}：项目的artifactId； ${project.version}：项目的version，与${version}等价； ${project.build.fianlName}：项目打包输出文件的名称，默认为${project.artifactId}-${project.version}； 自定义属性：用户可以在POM的元素下自定义Maven属性； Settings属性：用户使用settings.开头的属性引用settings.xml文件中XML元素的值； Java系统属性：所有Java系统属性都可以使用Maven属性引用； 环境变量属性：所有环境变量都可以使用以env.开头的Maven属性引用； 聚合工程12345678910111213141516&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;app&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;my-app&lt;/module&gt; &lt;module&gt;my-webapp&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 12345678910&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;app&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; ... 参考文献 Apache官方-快速入门 博客园-Maven属性、profile和资源过滤 博客园-Maven常用命令 CSDN-30个常用的 Maven 命令 CSDN-maven-surefire-plugin简介 附件maven-settings","tags":[{"name":"maven","slug":"maven","permalink":"https://jmzc4j.github.io/tags/maven/"}]},{"title":"使用Hexo搭建博客系统","date":"2019-08-27T22:29:42.000Z","path":"2019/08/28/使用Hexo搭建博客系统/","text":"Hexo是什么 Hexo是Node编写的一个基于markdown引擎的用来快速开发静态博客系统的框架； 官方网站：hexo.io; Hexo怎么用 准备环境 安装node.js,下载地址; 安装git,下载地址; 安装 hexo-cli 打开GitBash，执行$ npm install -g hexo-cli; 创建一个hexo的工作目录，进入目录执行hexo init &lt;folder&gt;; 进入初始化的那个目录，执行npm install来构建hexo并安装相应依赖; 配置_config.yml文件; 12345678910111213141516171819202122# Sitetitle: Jmzc&apos;s Blogsubtitle:description: Java,Study,Notes,Daily Life,keywords:author: Jmzclanguage: zh-CNtimezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://jmzc4j.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:jmzc4j/jmzc4j.github.io.git branch: master 执行hexo new &lt;title&gt; 新建一个blog； 在hexo根目录的source/_posts/找到title.md文件进行博客编辑; 执行hexo g 或 hexo generate 生成html静态页面（该页面在pubic文件夹下） 执行hexo s 或 hexo server 启动hexo服务在本地进行测试； 执行hexo d 或 hexo devlop 将生成的静态页发布到github上; 推送源码到github git init ssh-keygen -C &#39;jmzc-blog&#39;,然后将家目录中的公钥复制到github上 git remote add hexo-ssh git@github.com:jmzc4j/jmzc4j.github.io.git git checkout -b source git add . git commit -m &#39;hexo init&#39; git push hexo-ssh source 视频教程","tags":[{"name":"hexo","slug":"hexo","permalink":"https://jmzc4j.github.io/tags/hexo/"}]}]