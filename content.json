[{"title":"Mybatis常用配置","date":"2019-08-28T10:23:58.000Z","path":"2019/08/28/Mybatis常用配置/","text":"mybatis-config.xml配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 在配置文件中，属性的加载有三种方式： 1. resource或者url引入外部资源； 2. 在properties标签中使用property子标签进行定义，然后使用表达式引用； 3. 直接在要使用的位置硬编码； 注意：以上三种方式的优先级从低到高； --&gt; &lt;properties resource=&quot;db.properties&quot; /&gt; &lt;!-- 全局配置信息 logImpl：mybatis日志的实现； cacheEnabled：二级缓存开关； lazyLoadingEnabled：懒加载开关； aggressiveLazyLoading：积极懒加载开关，当懒加载时是否主动进行属性的初始化； mapUnderscoreToCamelCase：数据库列映射Java对象属性开关； useActualParamName：参数命名开关； --&gt; &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;slf4j&quot;/&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot; /&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot; /&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot; /&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useActualParamName&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- 以包扫描的方式进行别名定义，默认类名首字母小写（注意别名其实是不区分大小写的）； 当子包有相同的 类名存在时，可以使用@Alias注解进行签名； --&gt; &lt;package name=&quot;top.jmzc.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;plugins&gt; &lt;!-- 插件配置：以AOP的方式对Executor、MappedStatement、ParameterHandler、ResultSetHandler四大对象的方法进行拦截； 自定义插件的步骤： 1. 实现Intercept接口，逐一实现setProperties()、plugin()和intercept()方法； 2. 为定制的插件进行签名，使用@@Intercepts注解； 3. 在mybatis配置文件中进行声明； --&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;environments default=&quot;dev_mysql&quot;&gt; &lt;!-- 配置Session的环境，可以有多个环境，通过environments标签的default属性来切换； transactionManager：需要指定事务工厂的类型，这里使用的是别名，也可以实现ibatis提供的接口来进行定制； dataSource：需要指定数据源工厂的类型，同样使用的是别名，同样可以实现ibatis提供的接口进行定制； --&gt; &lt;environment id=&quot;dev_mysql&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.usernme&#125;&quot; /&gt; &lt;property name=&quot;pasword&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 为不同的数据库厂商的ProductName设置别名； ProductName可以从Connection接口的MetaData中得到； --&gt; &lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt; &lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&gt; &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot;/&gt; &lt;property name=&quot;SQL Server&quot; value=&quot;sqlserver&quot;/&gt; &lt;/databaseIdProvider&gt; &lt;mappers&gt; &lt;!-- 指定映射文件的包路径 --&gt; &lt;package name=&quot;top.jmzc.mapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt;","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://jmzc4j.github.io/tags/mybatis/"}]},{"title":"Redis常用配置","date":"2019-08-28T10:19:39.000Z","path":"2019/08/28/Redis常用配置/","text":"redis.cof常见配置说明 Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程daemonize no 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定pidfile /var/run/redis.pid 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字port 6379 绑定的主机地址bind 127.0.0.1 当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能timeout 300 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verboseloglevel verbose 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/nulllogfile stdout 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库iddatabases 16 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合saveRedis默认配置文件中提供了三个条件：save 900 1save 300 10save 60 10000分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大rdbcompression yes 指定本地数据库文件名，默认值为dump.rdbdbfilename dump.rdb 指定本地数据库存放目录dir ./ 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步slaveof 当master服务设置了密码保护时，slav服务连接master的密码masterauth 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭requirepass foobared 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息maxclients 128 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区maxmemory 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为noappendonly no 指定更新日志文件名，默认为appendonly.aofappendfilename appendonly.aof 指定更新日志条件，共有3个可选值：no：表示等操作系统进行数据缓存同步到磁盘（快）always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）everysec：表示每秒同步一次（折衷，默认值）appendfsync everysec 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）vm-enabled no 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享vm-swap-file /tmp/redis.swap 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0vm-max-memory 0 Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值vm-page-size 32 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。vm-pages 134217728 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4vm-max-threads 4 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启glueoutputbuf yes 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法hash-max-zipmap-entries 64hash-max-zipmap-value 512 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）activerehashing yes 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件include /path/to/local.conf","tags":[{"name":"redis","slug":"redis","permalink":"https://jmzc4j.github.io/tags/redis/"}]},{"title":"Docker入门","date":"2019-08-28T09:09:05.000Z","path":"2019/08/28/Docker入门/","text":"what is Docker是一个容器管理引擎，是一个轻量级的虚拟化技术；从镜像和容器的角度来定义一个应用； 将应用代码和配置等打包成一个可运行的环境（image），从而实现开发和生产环境的完美对接，达到一种一次构建到处运行的目的； repository、image、container为其最重要的三个组成部分。 image是由一层一层的文件系统组成，即UnionFS；其最底层是bootfs； image都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部；这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。 通过容器数据卷来实现数据持久化和数据共享； 安装与卸载 centos安装步骤 ①卸载旧版本 12345678$sudo yum remove docker \\docker-client \\docker-client-latest \\docker-common \\docker-latest \\docker-latest-logrotate \\docker-logrotate \\docker-engine ②安装依赖包 123$sudo yum install -y yum-utils \\device-mapper-persistent-data \\lvm2 ③配置仓库地址（这里使用阿里巴巴的国内镜像） 123456$sudo yum-config-manager \\ --add-repo \\https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo#这里可以清理yum缓存文件$yum makecache fast ④安装最新版或者自行选择版本 123456789#列出docker引擎的可用版本$yum list docker-ce --showduplicates | sort -r#选择版本进行安装#例如查到docker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stable#那么VERSION_STRING就是 docker-ce-18.09.1$sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io#也可以直接安装最新版$sudo yum install docker-ce docker-ce-cli containerd.io ⑤启动 1$sudo systemctl start docker ⑥测试 123$ sudo docker run hello-world或者执行docker version ⑦配置阿里云的镜像加速 123456789登录阿里云进入控制台，搜索容器镜像服务点击镜像加速器，然后找到centos的配置信息，按步骤配置即可vi /etc/docker/daemon.json#这里的镜像ID（u7dhnsts）不同人会不同&#123;&quot;registry-mirrors&quot;: [&quot;https://u7dhnsts.mirror.aliyuncs.com&quot;] &#125;sudo systemctl daemon-reloadsudo systemctl restart docker 卸载 12$ sudo yum remove docker-ce$ sudo rm -rf /var/lib/docker docker命令 docker --help|docker &lt;command&gt; --help：查看帮助 docker images ：查看镜像列表； docker rmi -f $(docker images -qa)：删除多个镜像； docker ps；查看正在运行的容器； docker rm -f $(docker ps -qa)：删除所有的容器； docker run &lt;containerName|containerID&gt; ：在镜像上创建一个容器（本地没有则会自动去远程仓库拉去）； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 OPTIONS说明（常用）：有些是一个减号，有些是两个减号 --name=&quot;容器新名字&quot;: 为容器指定一个名称； -d: 后台运行容器，并返回容器ID，也即启动守护式容器； -i：以交互模式运行容器，通常与 -t 同时使用； -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用； -P: 随机端口映射； -p: 指定端口映射，有以下四种格式 ip:hostPort:containerPort ip::containerPort hostPort:containerPort containerPort ``` 1. `docker search &lt;imageName:tag&gt;`：在仓库上搜索镜像，默认latest；1. `docker pull &lt;imageName:tag&gt;`：从远程拉取镜像到本地；1. `docker exec -it /bin/bash`：进入正在运行的容器；1. `docker commit -m &quot;xxx&quot; -a &quot;xxx&quot; &lt;containerName|containerID&gt; targetImage:tag`：基于容器生成一个新的镜像；1. `docker inspect &lt;containerName|containerID&gt;`：查看容器的详细信息；1. `docker info | docker version`：查看docker的简单信息；1. `docker logs -f &lt;containerName|containerID&gt;`：查看一个容器的历史记录1. `docker start|stop|restart &lt;containerName|containerID&gt;`：启动、停止、重启容器；1. `docker kill &lt;containerName|containerID&gt;`：强制停止容器；1. `docker cp containerID:path hostPath`：从容器拷贝文件到主机；1. `docker build -t 新镜像名字:TAG `：从Dockerfile中创建镜像；1. `docker history 镜像名`：查看镜像的变更历史；### Dockerfile- Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本；- Dockerfile约定1. 每条保留字指令都必须为大写字母且后面要跟随至少一个参数；2. 指令按照从上到下，顺序执行；3. 每条指令都会创建一个新的镜像层，并对镜像进行提交；- Dockerfile大致流程1. docker从基础镜像运行一个容器；2. 执行一条指令并对容器作出修改；3. 执行类似docker commit的操作提交一个新的镜像层；4. docker再基于刚提交的镜像运行一个新容器；5. 执行dockerfile中的下一条指令直到所有指令都执行完成；- Dockerfile中的关键字1. `FROM`：基础镜像，当前新镜像是基于哪个镜像的；1. `MAINTAINER`：镜像维护者的姓名和邮箱地址；1. `RUN`：容器构建时需要运行的命令；1. `EXPOSE`：当前容器对外暴露出的端口；1. `WORKDIR`：指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点；1. `ENV`：用来在构建镜像过程中设置环境变量；1. `ADD`：将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包；1. `COPY`：类似ADD，拷贝文件和目录到镜像中；但不进行解压；1. `VOLUME`：容器数据卷，用于数据保存和持久化工作；1. `CMD`：指定一个容器启动时要运行的命令；多个CMD会被覆盖；CMD 会被 docker run 之后的参数替换；1. `ENTRYPOINT`：ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数，以追加的方式执行；1. `ONBUILD`：当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发；- 自定义tomcat9 FROM centos MAINTAINER zzyy #把宿主机当前上下文的c.txt拷贝到容器/usr/local/路径下 COPY c.txt /usr/local/cincontainer.txt #把java与tomcat添加到容器中 ADD jdk-8u171-linux-x64.tar.gz /usr/local/ ADD apache-tomcat-9.0.8.tar.gz /usr/local/ #安装vim编辑器 RUN yum -y install vim #设置工作访问时候的WORKDIR路径，登录落脚点 ENV MYPATH /usr/local WORKDIR $MYPATH #配置java与tomcat环境变量 ENV JAVA_HOME /usr/local/jdk1.8.0_171 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.8 ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.8 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin #容器运行时监听的端口 EXPOSE 8080 #启动时运行tomcat ENTRYPOINT [“/usr/local/apache-tomcat-9.0.8/bin/startup.sh” ]CMD [“/usr/local/apache-tomcat-9.0.8/bin/catalina.sh”,”run”] CMD /usr/local/apache-tomcat-9.0.8/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.8/bin/logs/catalina.out 1### docker安装mysql5.7 docker run -d –name mysql-5.7 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /usr/local/mysql/data:/var/lib/mysql -v /usr/local/mysql/my.cnf:/etc/mysql/my.cnf -v /usr/local/mysql/conf.d:/etc/mysql/conf.d -v /usr/local//mysql/mysql.conf.d:/etc/mysql/mysql.conf.d -v /usr/local/mysql/log:/var/log/mysql –privileged=true mysql:5.7","tags":[{"name":"docker","slug":"docker","permalink":"https://jmzc4j.github.io/tags/docker/"}]},{"title":"Git入门","date":"2019-08-28T09:03:45.000Z","path":"2019/08/28/Git入门/","text":"what is git 是一个免费开源的分布式版本控制工具； 书籍-Pro Git：有关git的一切可阅读此书获取； why use it 既可以进行本地版本控制，又可以进行分布式版本控制； 不存在集中式版本控制工具的单点故障问题； 具有强大的分支管理； 由于是Linus开发，天然可以使用Linux命令； Git分支 假设有三个目录，并做了提交; 12$ git add README test.rb LICENSE$ git commit -m &apos;The initial commit of my project&apos; Git会对每个子目录进行校验，并将它们作为树对象存储在Git存储库中;然后Git创建一个提交对象，该对象具有元数据和指向根项目树的指针，因此它可以在需要时重新创建该快照。 ; 如果进行一些更改并再次提交，则下一个提交会存储指向紧接其之前的提交的指针。 ； Git中的一个分支只是一个指向其中一个提交的轻量级可移动指针。Git中的默认分支名称是master。当你开始提交时，你会得到一个master指向你最后一次提交的分支。每次提交时，master分支指针都会自动向前移动。 ; Git中的“主”分支不是特殊分支。它与任何其他分支完全一样。几乎每个存储库都有一个的唯一原因是该git init命令默认创建它，并且大多数人都不愿意更改它。 how to use it 安装 Linux说明; macOS下载地址; Windows下载地址; 首次配置 1234567# 安装Git时应该做的第一件事是设置用户名和电子邮件地址# --system：指定系统级别，--global：指定用户级别$ git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com# 使用以下方法查看所有设置及其来源$ git config --list --show-origin 获取帮助 123456$ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt;# 如果您不需要完整的联机帮助页面帮助，但只需要快速了解Git命令的可用选项，您可以使用-h或--help,如：$ git add -h 常用命令 $ git init：在现有目录中初始化存储库； $ git add xxx：将xxx文件从工作区添加到暂存区；untrace-stage； $ git commit -m &#39;initial project version&#39;：从暂存区永久提交到当前分支；stage-unmodified； $ git clone https://github.com/libgit2/libgit2 mylibgit：克隆存储库到本地并修改存储库的目录名； $ git status：查看文件状态，主要查看文件内容是否发生了变化； $ git diff：查看工作区与暂存区的更改； $ git diff --cached：查看暂存区与上次提交的更改； $ git log [--pretty=oneline]：查看提交历史，用于回退过去； $ git reflog：查看命令历史，用于追溯未来； $ git reset --hard commitID：切换版本； $ git rm --cached README：删除暂存区文件； $ git checkout xxx：同步到工作区； $ git commit --amend：重做提交； $ git remote -v：查看远程时要使用的短名称存储的URL； $ git remote add &lt;shortname&gt; &lt;url&gt;：为远程库添加一个新的短名称； $ git fetch &lt;remote&gt;：从远处库抓取数据； $ git push &lt;remote&gt; &lt;branch&gt;：推送当前分支到远程库 $ git remote rename pb paul：更改远程库别名pb为paul； $ git remote remove paul：删除一个远程库url； $ git push &lt;remote&gt;：抓取并合并到本地； $ git branch testing：创建一个testing分支； $ git checkout testing:切换分支； $ git merge hotfix：合并hotfix分支到当前分支上； $ git branch -d hotfix：删除分支； $ git branch -v：查看每个分支上的最后一次提交； $ git branch --merged：查看已经合并了的分支，不带星号的分支可以删除； $ git push &lt;remote&gt; &lt;branch&gt;：将本地分支推送到一个名称不同的远程分支； $ git checkout -b sf origin/serverfix：设置名称与远程分支不同的本地分支； git branch -u origin/serverfix：更新当前分支为远程分支； $ git push origin --delete serverfix：完成合并删除远程分支； 参考文献 书籍-Pro Git; 博客园-Git命令总结; 廖雪峰-Git教程;","tags":[{"name":"git","slug":"git","permalink":"https://jmzc4j.github.io/tags/git/"}]},{"title":"Redis命令","date":"2019-08-28T09:01:17.000Z","path":"2019/08/28/Redis命令/","text":"what is Redis全称为 Remote Dictionary Server; Redis是一个遵守BSD协议的开源的基于内存的数据结构存储服务；可以用做数据库、缓存和消息中间件；（官方） Redis是意大利人用C语言编写的一个高性能的（key/value）分布式的NoSQL数据库，支持多种数据类型并支持持久化； how to use it通用命令 dbsize select dbIndex flushdb flushall keys * exists key move key dbIndex expire key：设置key的存活时间（秒单位） ttl key：查看key的剩余存活时长，返回值含义（-1，永恒；-2，过期），过期就会被从内存中删除该key persist key：去掉有效期设置 type key string 常用 set/get/del/append/strlen key incr/decr key incrby/decrby key increment getrange/setrange key startIndex endIndex：获取key对应的指定范围的value，第一个索引为0，最后一个索引为-1 setex(with expire) key second value setnx(if not exist) key value mset/mget/msetnx key ：添加、获取多个kv getset list 常用 lpush/rpush/lrange lpop/rpop lIndex key lrem key count value ltrim key start end ；截取start到end的元素再赋值给原来的key rpoplpush srcList targetList：当scr与target相同就构成了一个循环 lInsert key before/after v1 v2 lset key index value set 常用 sadd smembers key sismember key v1 scard：获取元素个数 srem key value srandmember key num：随机取出num个元素 spop key smove key1 key2 value-in-key1：将key1中的某个值移动到key的集合中 sdiff key1 key2：获取在key1集合但不在key2集合的元素 sinter key1 key2 sunion key1 key2 hash 常用 hset/hget/hdel/hmset/hmget/hgetall hlen hexists key in-key hkeys/hvals hincrby/hincrbyfloat hsetnx zset 常用 zadd/zrange：zadd zset1 60 v1 70 v2 80 v3 90 v4 100 v5 zrangebyscore key startScore endScore：默认取左闭右闭区间，可以使用左小括号来更改为开区间 zcard/zcount key score1 score2 zrank key value：获取value在key集合中的排名，即获取下标 zscore key value zrevrange zrevrank key value zrevrangebyscore key endScore startScore","tags":[{"name":"redis","slug":"redis","permalink":"https://jmzc4j.github.io/tags/redis/"}]},{"title":"Maven入门","date":"2019-08-28T08:40:39.000Z","path":"2019/08/28/Maven入门/","text":"what is maven 是 apache软件基金会的一个产品； maven 是一个将模型应用于工程的管理系统； maven 是 一个Java项目的构建和管理工具，包括项目生命周期的管理和项目依赖的管理； why use it 简化项目构建，缩短了开发周期； 将代码与架包分离，仅仅在POM中提供依赖的引用即可； 统一的目录结构和约定，有利于开发者理解开发原则； how to config it 配置本地仓库路径 12345&lt;settings&gt; ... &lt;localRepository&gt;D:\\Repository\\mvnRepo&lt;/localRepository&gt; ...&lt;/settings&gt; 配置远程镜像仓库 123456789101112&lt;settings&gt; ... &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt;...&lt;/settings&gt; 配置JDK版本（也可以使用编译插件） 12345678910111213141516171819&lt;settings&gt; ... &lt;profiles&gt; &lt;!--定义工程的JDK版本--&gt; &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeteByDefault&gt;true&lt;/activeteByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; ...&lt;/settings&gt; how to use it maven的基本工作单元就是POM，POM中包含着项目的部分描述信息，所有的maven操作都是从POM开始的； maven的指令代表着生命周期中的不同阶段，这些指令仅仅是一个抽象层的定义，真实的操作都有由相应的插件来处理的； maven项目创建,使用原型（模板）创建不同的项目，过程中默认选择模板7（快速版）和默认1.0-snapshot版本； 1234mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DgroupId=com.mycompany.app -DartifactId=my-app 创建结果如下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- 指定模型的版本，一般不会变，统一版本可以确保稳定性 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 指定坐标和打包方式： groupId：组织和项目唯一标识； artifactId：工程基础名称； version：版本号和类型； packaging：打包方式，默认jar，同时约束了生命周期的最终阶段； --&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- Maven生成的文档相关： name:项目的显示名称; url:项目站点的位置; description:项目的基本描述; --&gt; &lt;name&gt;my-app&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;！-- 自定义的属性，EL方式引用 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 目录结构如下：(使用IDE创建的还会有resource目录) 123456789101112131415my-app|-- pom.xml`-- src |-- main | `-- java | `-- com | `-- mycompany | `-- app | `-- App.java `-- test `-- java `-- com `-- mycompany `-- app `-- AppTest.java 其他maven指令： mvn compile：编译源代码； mvn test：编译测试源代码并指定命名约定的单元测试； mvn test-compile：仅编译吃源代码； mvn package：打包到target目录中； mvn install：打包到本地仓库中； mvn site：生成项目的web站点； mvn clean：清理target的目录； mvn eclipse:eclipse：生成eclispe项目； mvn idea:idea：生成idea项目； mvn eclipse:clean：清楚eclispe配置； mvn dependency:list：列出所有依赖； mvn deploy：上传到私服； mvn test -skipping compile -skipping test-compile：不编译仅测试； mvn -version/-v：查看maven版本； mvn jetty:run：jetty上运行； mvn -e：显示错误信息； mvn validate：验证工程是否正确，所有需要的资源是否可用； mvn verify：运行任何检查，验证包是否有效且达到质量标准； mvn dependency:tree：输出依赖树； mvn tomcat:run：在tomcat6上运行； mvn help:describe -Dplugin=pluginName -Dgoal(或-Dmojo)=goalName：列出某个插件的goal信息； mvn tomcat7:run -Dmaven.test.skip=true：跳过测试； mvn eclipse:eclipse -DskipTests：生成导入Eclipse中的项目列表。一般在项目导入之前使用； mvn install:install-file -DgroupId=com -DartifactId=client -Dversion=0.1.0 -Dpackaging=jar -Dfile=d:\\client-0.1.0.jar：打包jar到本地库； 其他配置 如何发布jar到远程仓库1234567&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;mycompany-repository&lt;/id&gt; &lt;name&gt;MyCompany Repository&lt;/name&gt; &lt;url&gt;scp://repository.mycompany.com/repository/maven2&lt;/url&gt; &lt;/repository&gt;&lt;/distributionManagement&gt; 12345678910111213141516&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; ... &lt;servers&gt; &lt;server&gt; &lt;id&gt;mycompany-repository&lt;/id&gt; &lt;username&gt;jvanzyl&lt;/username&gt; &lt;!-- Default value is ~/.ssh/id_dsa --&gt; &lt;privateKey&gt;/path/to/identity&lt;/privateKey&gt; (default is ~/.ssh/id_dsa) &lt;passphrase&gt;my_key_passphrase&lt;/passphrase&gt; &lt;/server&gt; &lt;/servers&gt; ...&lt;/settings&gt; 编译插件 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 测试插件: 123456789&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.18.1&lt;/version&gt; &lt;!-- 同样实现跳过生命周期中的测试阶段 --&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt;&lt;/plugin&gt; 资源文件插件 1234567891011121314151617181920212223242526272829303132333435&lt;project&gt; ... &lt;build&gt; ... &lt;resources&gt; &lt;!-- 资源插件默认行为只是将项目主资源文件复制到主代码编译输出目录中，将测试资源文件复制到测试代码编译输出目录中。 --&gt; &lt;resource&gt; &lt;!-- 指定资源文件目录 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- 开启资源过滤 ：（默认false） filtering：作用是用环境变量，pom文件里定义的属性和指定文件里的属性替换属性文件的占位符。 --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;!-- includes之中的也会被过滤 --&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;!-- excludes之外的不会被过滤 --&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.xml&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; ... &lt;/resources&gt; ... &lt;/build&gt; ... &lt;/project&gt; mybatis逆向工程插件 1234567891011&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt;&lt;/plugin&gt;goal：mybatis-generator:generate Maven中的属性 内置属性： ${basedir}：项目的根目录(包含pom.xml文件的目录； ${version}：项目版本； POM属性： ${project.build.sourceDirectory}：项目的主源码目录，默认为src/main/java； ${project.build.testSourceDirectory}：项目的测试源码目录，默认为src/test/java； ${project.build.directory}：项目构件输出目录，默认为target/； ${project.outputDirectory}：项目主代码编译输出目录，默认为target/classes/； ${project.testOutputDirectory}：项目测试代码编译输出目录，默认为target/test-classes/； ${project.groupId}：项目的groupId； ${project.artifactId}：项目的artifactId； ${project.version}：项目的version，与${version}等价； ${project.build.fianlName}：项目打包输出文件的名称，默认为${project.artifactId}-${project.version}； 自定义属性：用户可以在POM的元素下自定义Maven属性； Settings属性：用户使用settings.开头的属性引用settings.xml文件中XML元素的值； Java系统属性：所有Java系统属性都可以使用Maven属性引用； 环境变量属性：所有环境变量都可以使用以env.开头的Maven属性引用； 聚合工程12345678910111213141516&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;app&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;my-app&lt;/module&gt; &lt;module&gt;my-webapp&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 12345678910&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;app&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; ... 参考文献 Apache官方-快速入门 博客园-Maven属性、profile和资源过滤 博客园-Maven常用命令 CSDN-30个常用的 Maven 命令 CSDN-maven-surefire-plugin简介","tags":[{"name":"maven","slug":"maven","permalink":"https://jmzc4j.github.io/tags/maven/"}]},{"title":"使用Hexo搭建博客系统","date":"2019-08-27T22:29:42.000Z","path":"2019/08/28/使用Hexo搭建博客系统/","text":"Hexo是什么 Hexo是Node编写的一个基于markdown引擎的用来快速开发静态博客系统的框架； 官方网站：hexo.io; Hexo怎么用 准备环境 安装node.js,下载地址; 安装git,下载地址; 安装 hexo-cli 打开GitBash，执行$ npm install -g hexo-cli; 创建一个hexo的工作目录，进入目录执行hexo init &lt;folder&gt;; 进入初始化的那个目录，执行npm install来构建hexo并安装相应依赖; 配置_config.yml文件; 12345678910111213141516171819202122# Sitetitle: Jmzc&apos;s Blogsubtitle:description: Java,Study,Notes,Daily Life,keywords:author: Jmzclanguage: zh-CNtimezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://jmzc4j.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:jmzc4j/jmzc4j.github.io.git branch: master 执行hexo new &lt;title&gt; 新建一个blog； 在hexo根目录的source/_posts/找到title.md文件进行博客编辑; 执行hexo g 或 hexo generate 生成html静态页面（该页面在pubic文件夹下） 执行hexo s 或 hexo server 启动hexo服务在本地进行测试； 执行hexo d 或 hexo devlop 将生成的静态页发布到github上; 推送源码到github git init ssh-keygen -C &#39;jmzc-blog&#39;,然后将家目录中的公钥复制到github上 git remote add hexo-ssh git@github.com:jmzc4j/jmzc4j.github.io.git git checkout -b source git add . git commit -m &#39;hexo init&#39; git push hexo-ssh source","tags":[{"name":"hexo","slug":"hexo","permalink":"https://jmzc4j.github.io/tags/hexo/"}]}]