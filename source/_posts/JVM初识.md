---
title: JVM初识
date: 2019-08-29 13:01:43
tags: jvm
categories: 学习笔记
---
### JVM内存模型
- JVM是运行在操作系统之上的，它与硬件没有直接的交互；
{% asset_img jvm.png JVM模型 %}
- 堆空间和方法区被线程共享;程序计数器、虚拟机栈和本地方法栈被线程私有；
- 常见的JVM实现有SUN hotspot、BEA jrockit、IBM j9；

### 类装载器
- 负责加载class文件，class文件在文件开头有特定的文件标示，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定;
- 装载过程：
	1. 加载：查找并加载字节码文件到内存
		- 准确说是将字节码文件的内容加载到运行时数据区的方法区中，并在内存中创建一个Class对象。
	2. 连接
		- 验证：验证字节码文件的正确性
		- 准备：为静态变量分配空间并进行默认初始化
		- 解析：将符号引用转变为直接引用
	3. 初始化：为静态变量进行真实初始化
		- 只有在首次主
- 装载器分类
{% asset_img classloader.png 类装载器继承体系 %}
- 虚拟机自带的加载器:
	启动类加载器（Bootstrap）C++
	扩展类加载器（Extension）Java
	应用程序类加载器（App）Java
	也叫系统类加载器，加载当前应用的classpath的所有类
- 用户自定义加载器  Java.lang.ClassLoader的子类，用户可以定制类的加载方式;

### 执行引擎
- Execution Engine执行引擎负责解释命令，提交操作系统执行（java、javac）;

### Native Interface本地接口
- Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问;

### 本地方法栈
- 登记native方法，在Execution Engine执行时加载本地方法库;

### PC寄存器
- 每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记;

### 虚拟机栈
- 主管Java程序的运行，在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。基本类型的变量、实例方法、引用类型变量都是在函数的栈内存中分配。
- java.lang.StackOverflowError：当线程请求深度大于虚拟机允许的深度时发生异常;

### 方法区
- 方法区是线程共享的，通常用来保存装载的类的元结构信息。
比如：运行时常量池+静态变量+常量+字段+方法字节码+在类/实例/接口初始化用到的特殊方法等。
- 通常和永久区关联在一起(Java7之前)，但具体的跟JVM的实现和版本有关。

### 堆空间
- 一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行。
- 堆内存逻辑上分为三部分：新生+养老+永久（JDK8以前）;
{% asset_img heap.png 堆内存模型 %}
#### 新生区
- 新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命；
- 新生区又分为两部分：伊甸区（Eden）和幸存者区（Survivor），所有的类都是在伊甸区被new出来的。幸存区有两个： 0区（Survivor 0 space）和1区（Survivor 1 space）;
- 当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(MinorGC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存0区.若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生MajorGC（FullGC），进行养老区的内存清理。若养老区执行了FullGC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。
- 如果出现java.lang.OutOfMemoryError: Java heap space异常，说明Java虚拟机的堆内存不够。原因有二：
	1. Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。(初始大小一般是物理内存1/64,最大1/4)
	2. 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。
	3. 新生代调整参数：-Xmn；永久代调整参数：-XX:PermSize和-XX:MaxPermSize。
	4. -XX:+PrintGCDetails  :输出GC处理日志。
- 使用如下API获取JVM堆内存参数
	```
	long maxMemory = Runtime.getRuntime().maxMemory() ;//返回 Java 虚拟机试图使用的最大内存量。
	long totalMemory = Runtime.getRuntime().totalMemory() ;//返回 Java 虚拟机中的内存总量。
	```
### JVM采用分代回收机制
- 新生代使用复制算法copying，会浪费50%空间；
- 年老代使用标记清除和标记整理算法mark-sweep（会产生不连续的内存碎片）和mark-compack；


